# 设计模式之美

### 开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！

### 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？

### 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

***如何评价代码质量的高低？***

代码质量高低是一个综合各种因素得到的结论，我们并不能通过单一的维度去评价一段代码的好坏。

不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。而且，各种评价维度也不是非黑即白的。

对一段代码的质量评价，常常有很强的主观性。

***最常用的评价标准有哪几个？***

**可维护性（maintainability）**

我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

***可读性（readability）***

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时有很多疑问，那就说明你的代码可读性有待提高了。

**可扩展性（extensibility）**

说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

**灵活性（flexibility）**

**简洁性（simplicity）**

实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。

**可复用性（reusability）**

**可测试性（testability）**

代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。

***如何才能写出高质量的代码？***

问如何写出高质量的代码，也就等同于在问如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

### 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

***面向对象***

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

***设计原则***

对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。

***设计模式***

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。

这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

***编程规范***

***代码重构***

不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

***五者之间的联系***

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。

### 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？

***什么是面向对象编程和面向对象编程语言？***

面向对象编程是一种编程范式或编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石 。

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

***如何判定某编程语言是否是面向对象编程语言？***

我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制、是否完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。

***什么是面向对象分析和面向对象设计？***

分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。

简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。

### 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

***封装（Encapsulation）***

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持，这个语法机制就是访问权限控制。

**封装的意义是什么？它能解决什么编程问题？**

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解，而这对于调用者来说也是一种负担。

***抽象（Abstraction）***

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制来实现抽象这一特性。

类的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档了解其提供了什么功能，就可以直接使用了。

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制就可以实现抽象特性，所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。

**抽象的意义是什么？它能解决什么编程问题？**

在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放，对修改关闭）、代码解耦（降低代码的耦合性）等。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候不用去修改其定义。

***继承（Inheritance）***

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承。

**继承存在的意义是什么？它能解决什么编程问题？**

继承最大的一个好处就是代码复用。不过，这并不是继承所独有的，我们可以通过其他方式来解决代码复用的问题，比如利用组合关系而不是继承关系。

猫属于哺乳动物，从人类认知的角度上来说是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

***多态（Polymorphism）***

多态是指子类可以替换父类，在实际的代码运行过程中调用子类的方法实现。

**多态特性的实现方式**

利用继承加方法重写

利用接口类语法

利用 duck-typing 语法

**多态特性存在的意义是什么？它能解决什么编程问题？**

多态特性能提高代码的可扩展性和复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等等。

### 06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？

***什么是面向过程编程与面向过程编程语言？***

面向过程编程是一种编程范式或编程风格，它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

面向过程编程语言最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。

***面向对象编程相比面向过程编程有哪些优势？***

**OOP 更加能够应对大规模复杂程序的开发**

因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线，如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法就会比较吃力。

面向对象编程以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候思路更加清晰。

类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

**OOP 风格的代码更易复用、易扩展、易维护**

面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。

**OOP 语言更加人性化、更加高级、更加智能**

在进行面向对象编程时候，我们是在思考如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。

### 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

***哪些代码设计看似是面向对象，实际是面向过程的？***

**滥用 getter、setter 方法**

它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。

在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的危险。

**滥用全局变量和全局方法**

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。

大而全的 Constants 类

影响代码的可维护性；增加代码的编译时间，每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间；影响代码的复用性。

将 Constants 类拆解为功能更加单一的多个类；不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中，这样也提高了类设计的内聚性和代码的复用性。

Utils 类

仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。

**定义数据和方法分离的类**

一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中，这就是典型的面向过程的编程风格。

***在面向对象编程中，为什么容易写出面向过程风格的代码？***

你在生活中去完成一个任务，一般都会思考应该先做什么后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反，它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来完成整个任务。

在面向对象编程中，类的设计还是挺需要技巧的，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。

***面向过程编程及面向过程编程语言就真的无用武之地了吗？***

如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主数据为辅，那脚本式的面向过程的编程风格就更适合一些。

面向对象和面向过程两种编程风格也并不是非黑即白、完全对立的。不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。

### 08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？

***什么是抽象类和接口？区别在哪里？***

**抽象类**

抽象类不允许被实例化，只能被继承。

抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现，不包含代码实现的方法叫作抽象方法。

子类继承抽象类，必须实现抽象类中的所有抽象方法。

**接口**

接口不能包含属性（也就是成员变量）。

接口只能声明方法，方法不能包含代码实现。

类实现接口的时候，必须实现接口中声明的所有方法。

**区别**

继承关系是一种 is-a 的关系，抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

***抽象类和接口能解决什么编程问题？***

**我们为什么需要抽象类？它能够解决什么编程问题？**

```java
public class Logger {
    protected boolean isLoggable() {...}
}
public class FileLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。

```java
Logger logger = new FileLogger();
// 编译错误
logger.log(Level.ERROR, "");
```

```java
public class Logger {
    protected boolean isLoggable() {...}
    public void log(Level level, String mesage) {}
}
public class FileLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路能用，但是，它显然没有通过抽象类的实现思路优雅：

在 Logger 中定义一个空的方法，会影响代码的可读性。

当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。

Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法，这也增加了类被误用的风险。

**我们为什么需要接口？它能够解决什么编程问题？**

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。

接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

***如何决定该用抽象类还是接口？***

如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就使用抽象类；如果我们要表示一种 has-a 的关系，并且为了解决抽象而非代码复用的问题，我们就使用接口。

从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

### 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

***如何解读“基于接口而非实现编程”中的“接口”二字？***

从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。

如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。

应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计不仅能应对当下的需求，而且在将来需求发生变化的时候仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

***如何将这条原则应用到实战中？***

```java
public class AliyunImageStore {
    public void createBucketIfNotExisting(String bucketName) {...}
    public String generateAccessToken() {...}
    public String uploadToAliyun(Image image, String bucketName, String accessToken) {...}
    public Image downloadFromAliyun(String url, String accessToken) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        AliyunImageStore imageStore = new AliyunImageStore();
        imageStore.createBucketIfNotExisting(BUCKET_NAME);
        String accessToken = imageStore.generateAccessToken();
        imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
    }
}
```

新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法在 PrivateImageStore 类中都逐一定义并重新实现一遍。

**“魔鬼细节”**

AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。而我们把这种包含“aliyun”字眼的方法照抄到 PrivateImageStore 类中显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。

将图片存储到阿里云的流程跟存储到私有云的流程可能并不是完全一致的。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。

**“基于接口而非实现编程”**

函数的命名不能暴露任何实现细节。

封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法给调用者使用。

为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传（或下载）功能协议。使用者依赖接口，而不是具体的实现类来编程。

```java
public interface ImageStore {
    String upload(Image image, String bucketName);
    Image download(String url);
}

public class AliyunImageStore implements ImageStore {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        String accessToken = generateAccessToken();
        ...
    }
    public Image download(String url) {
        String accessToken = generateAccessToken();
        ...
    }
    private void createBucketIfNotExisting(String bucketName) {...}
    private String generateAccessToken() {...}
}

public class PrivateImageStore implements ImageStore  {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        ...
    }
    public Image download(String url) {...}
    private void createBucketIfNotExisting(String bucketName) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        ImageStore imageStore = new PrivateImageStore();
        imagestore.upload(image, BUCKET_NAME);
    }
}
```

我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节，接口的定义只表明做什么而不是怎么做。而且，在设计接口的时候，我们要多思考一下这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候不需要任何接口定义的改动。

***是否需要为每个类定义接口？***

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

### 10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

***为什么不推荐使用继承？***

鸟类 / 是否会飞 / 是否会叫 / 是否会下蛋 ...

继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

***组合相比继承有哪些优势？***

实际上，我们可以利用组合、接口、委托这三个技术手段来解决继承存在的问题。

```java
public interface EggLayable {
    void layEgg();
}
// 解决代码重复的问题
public class EggLayAbility implements EggLayable {
    @Override
    public void layEgg() {...}
}
public class Ostrich implements Tweetable, EggLayable {
    private TweetAbility tweetAbility = new TweetAbility();
    // 组合
    private EggLayAbility eggLayAbility = new EggLayAbility();
    @Override
    public void tweet() {
        tweetAbility.tweet();
    }
    @Override
    public void layEgg() {
        // 委托
        eggLayAbility.layEgg();
    }
}
```

***如何判断该用组合还是继承？***

继承改写成组合意味着要做更细粒度的类的拆分，这也就意味着我们要定义更多的类和接口，类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。这个时候，使用组合就更加合理、更加灵活。

如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。

```java
public class FeignClient {
    public void encode(String url) {...}
}

public void demofunction(FeignClient feignClient) {
    //...
    feignClient.encode(url);
    //...
}

public class CustomizedFeignClient extends FeignClient {
    @Override
    public void encode(String url) {...}
}

// 调用
FeignClient client = new CustomizedFeignClient();
demofunction(client);
```

### 11 | 实战一（上）：业务开发常用的基于贫血模型的 MVC 架构违背 OOP 吗？

***什么是基于贫血模型的传统开发模式？***

Service 层的数据和业务逻辑被分割到 BO 和 Service 两个类中，像 UserBo 这样只包含数据不包含业务逻辑的类就叫作贫血模型（Anemic Domain Model）。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

***什么是基于充血模型的 DDD 开发模式？***

**什么是充血模型？**

充血模型（Rich Domain Model），数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

**什么是领域驱动设计？**

领域驱动设计（即 DDD）主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。

做好领域驱动设计的关键是看你对自己所做业务的熟悉程度，而不是对领域驱动设计这个概念本身的掌握程度。

**基于充血模型的 DDD 开发模式**

实际上，基于充血模型的 DDD 开发模式实现的代码也是按照 MVC 三层架构分层的，Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。

在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑，业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分，Domain 就相当于贫血模型中的 BO，不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑，而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统开发模式重 Service 轻 BO；基于充血模型的 DDD 开发模式轻 Service 重 Domain。

***为什么基于贫血模型的传统开发模式如此受欢迎？***

第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。

第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格，我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑，而不是像贫血模型那样只需要定义数据，之后有什么功能开发需求就在 Service 层定义什么操作，不需要事先做太多设计。

第三点原因是，思维已固化，转型有成本。

***什么项目应该考虑使用基于充血模型的 DDD 开发模式？***

在基于充血模型的 DDD 开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层，新功能需求的开发都基于之前定义好的这些领域模型来完成。

我们知道，越复杂的系统对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。

### 12 | 实战一（下）：如何利用基于充血模型的 DDD 开发一个虚拟钱包系统？

```java
public class VirtualWallet {
    private Long id;
    private Long createTime = System.currentTimeMillis();
    private BigDecimal balance = BigDecimal.ZERO;
    private boolean isAllowedOverdraft = true;
    private BigDecimal overdraftAmount = BigDecimal.ZERO;
    private BigDecimal frozenAmount = BigDecimal.ZERO;
    public VirtualWallet(Long preAllocatedId) {
        this.id = preAllocatedId;
    }
    public void freeze(BigDecimal amount) {...}
    public void unfreeze(BigDecimal amount) {...}
    public void increaseOverdraftAmount(BigDecimal amount) {...}
    public void decreaseOverdraftAmount(BigDecimal amount) {...}
    public void closeOverdraft() {...}
    public void openOverdraft() {...}
    public BigDecimal balance() {
        return this.balance;
    }
    public BigDecimal getAvaliableBalance() {
        BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
        if (isAllowedOverdraft) {
            totalAvaliableBalance += this.overdraftAmount;
        }
        return totalAvaliableBalance;
    }
    public void debit(BigDecimal amount) {
        BigDecimal totalAvaliableBalance = getAvaliableBalance();
        if (totoalAvaliableBalance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException(...);
        }
        this.balance.subtract(amount);
    }
    public void credit(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException(...);
        }
        this.balance.add(amount);
    }
}

public class VirtualWalletService {
    private VirtualWalletRepository walletRepo;
    private VirtualWalletTransactionRepository transactionRepo;
    public VirtualWallet getVirtualWallet(Long walletId) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        return wallet;
    }
    public BigDecimal getBalance(Long walletId) {
        return walletRepo.getBalance(walletId);
    }
    public void debit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        wallet.debit(amount);
        walletRepo.updateBalance(walletId, wallet.balance());
    }
    public void credit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        wallet.credit(amount);
        walletRepo.updateBalance(walletId, wallet.balance());
    }
    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setFromWalletId(fromWalletId);
        transactionEntity.setToWalletId(toWalletId);
        transactionEntity.setStatus(Status.TO_BE_EXECUTED);
        Long transactionId = transactionRepo.saveTransaction(transactionEntity);
        try {
            debit(fromWalletId, amount);
            credit(toWalletId, amount);
        } catch (InsufficientBalanceException e) {
            transactionRepo.updateStatus(transactionId, Status.CLOSED);
            ...
        } catch (Exception e) {
            transactionRepo.updateStatus(transactionId, Status.FAILED);
            ...
        }
        transactionRepo.updateStatus(transactionId, Status.EXECUTED);
    }
}
```

***辩证思考与灵活应用***

**在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在我们的代码设计与实现中并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？**

Service 类负责与 Repository 交流：之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。

Service 类负责跨领域模型的业务聚合功能：VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。

Service 类负责一些非功能性及与三方系统交互的工作：比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等。

**在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？**

Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑，Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

我们再来说说 Controller 层的 VO，实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象），它主要是作为接口的数据传输承载体将数据发送给其他系统，从功能上来讲，它理应不包含业务逻辑只包含数据。所以，我们将它设计成贫血模型也是比较合理的。

### 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？

***案例介绍和难点剖析***

**需求不明确**

面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理来搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。

**缺少锻炼**

开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力甚至逻辑思维能力的要求都是比较高的。

***对案例进行需求分析***

提出问题，然后再解决问题，是一个非常好的迭代优化方法。

需求分析的过程实际上是一个不断迭代优化的过程，我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

### 14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？

***如何进行面向对象设计？***

面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。

**划分职责进而识别出有哪些类**

在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。

把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。

根据需求描述，把其中涉及的功能点一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。

注意，拆解出来的每个功能点要尽可能的小，每个功能点只负责做一件很小的事情（专业叫法是“单一职责”）。

针对复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部进行面向对象设计，而模块的划分和识别跟类的划分和识别是类似的套路。

**定义类及其属性和方法**

识别出需求描述中的动词作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词作为候选属性，然后同样进行过滤筛选。

**定义类与类之间的交互关系**

UML 统一建模语言中定义了六种类之间的关系，它们分别是：泛化、实现、关联、聚合、组合、依赖。

泛化（Generalization）可以简单理解为继承关系。

```java
public class A { ... }
public class B extends A { ... }
```

实现（Realization）一般是指接口和实现类之间的关系。

```java
public interface A {...}
public class B implements A { ... }
```

聚合（Aggregation）是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 类对象。

```java
public class A {
    private B b;
    public A(B b) {
        this.b = b;
    }
}
```

组合（Composition）也是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期依赖 A 类对象的生命周期，B 类对象不可单独存在。

```java
public class A {
    private B b;
    public A() {
        this.b = new B();
    }
}
```

关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。

依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数、返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。

泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。

**类组装起来并提供执行入口**

***辩证思考与灵活应用***

整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程，我们没法严格地按照顺序执行各个步骤。

### 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？

***如何理解单一职责原则（SRP）？***

A class or module should have a single responsibility.

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

***如何判断类的职责是否足够单一？***

不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。

评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类拆分成几个更细粒度的类，这就是所谓的持续重构。

**从侧面上判定一个类的职责是否够单一**

类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；

类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；

私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；

比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；

类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆分出来。

**那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？**

从另一个角度来看，当一个类的代码读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能却要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。

***类的职责是否设计得越单一越好？***

内聚性 / 可维护性

### 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

***如何理解“对扩展开放、修改关闭”？***

software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.

添加一个新的功能应该是在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

```java
public class Alert {
    private AlertRule rule;
    private Notification notification;

    public Alert(AlertRule rule, Notification notification) {
        this.rule = rule;
        this.notification = notification;
    }

    public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {
        long tps = requestCount / durationOfSeconds;
        if (tps > rule.getMatchedRule(api).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
    }
}
```

```java
public class Alert {

    // ...

    // 改动一：添加参数 timeoutCount
    public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {
        long tps = requestCount / durationOfSeconds;
        if (tps > rule.getMatchedRule(api).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
        // 改动二：添加接口超时处理逻辑
        long timeoutTps = timeoutCount / durationOfSeconds;
        if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
    }
}
```

一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改。

重构的内容主要包含两部分：

第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类；

第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。

```java
public class Alert {
    private List<AlertHandler> alertHandlers = new ArrayList<>();

    public void addAlertHandler(AlertHandler alertHandler) {
        this.alertHandlers.add(alertHandler);
    }

    public void check(ApiStatInfo apiStatInfo) {
        for (AlertHandler handler : alertHandlers) {
            handler.check(apiStatInfo);
        }
    }
}

public class ApiStatInfo {
    private String api;
    private long requestCount;
    private long errorCount;
    private long durationOfSeconds;
}

public abstract class AlertHandler {
    protected AlertRule rule;
    protected Notification notification;
    public AlertHandler(AlertRule rule, Notification notification) {
        this.rule = rule;
        this.notification = notification;
    }
    public abstract void check(ApiStatInfo apiStatInfo);
}

public class TpsAlertHandler extends AlertHandler {
    public TpsAlertHandler(AlertRule rule, Notification notification) {
        super(rule, notification);
    }

    @Override
    public void check(ApiStatInfo apiStatInfo) {
        long tps = apiStatInfo.getRequestCount() / apiStatInfo.getDurationOfSeconds();
        if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
    }
}

public class ErrorAlertHandler extends AlertHandler {
    public ErrorAlertHandler(AlertRule rule, Notification notification){
        super(rule, notification);
    }

    @Override
    public void check(ApiStatInfo apiStatInfo) {
        if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
    }
}
```

ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。

```java
public class ApplicationContext {
    private AlertRule alertRule;
    private Notification notification;
    private Alert alert;

    public void initializeBeans() {
        alertRule = new AlertRule();
        notification = new Notification();
        alert = new Alert();
        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
        alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
    }
    public Alert getAlert() { return alert; }

    private static final ApplicationContext instance = new ApplicationContext();
    private ApplicationContext() {
        instance.initializeBeans();
    }
    public static ApplicationContext getInstance() {
        return instance;
    }
}

public class Demo {
    public static void main(String[] args) {
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
    }
}
```

重构之后的代码添加新功能：

```java
public class Alert {
    // 代码未改动
}
public class ApiStatInfo {
    // ...
    // 改动一：添加新字段
    private long timeoutCount;
}
public abstract class AlertHandler {
    // 代码未改动
}
public class TpsAlertHandler extends AlertHandler {
    // 代码未改动
}
public class ErrorAlertHandler extends AlertHandler {
    // 代码未改动
}
// 改动二：添加新的 handler
public class TimeoutAlertHandler extends AlertHandler { ... }

public class ApplicationContext {
    // ...
  public void initializeBeans() {
      // ...
      alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
      alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
      // 改动三：注册 handler
      alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
  }
  //...
}

public class Demo {
    public static void main(String[] args) {
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        // ...
        // 改动四：设置 tiemoutCount
        apiStatInfo.setTimeoutCount(200);
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
}
```

***修改代码就意味着违背开闭原则吗？***

只要它没有破坏原有代码的正常运行，没有破坏原有的单元测试，我们就可以说这是一个合格的代码改动。

添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作才能构建成可运行的的程序，这部分代码的修改是在所难免的。

***如何做到“对扩展开放、修改关闭”？***

**为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。**

在写代码的时候，我们要多花点时间往前思考一下，这段代码未来可能有哪些需求变更？如何设计代码结构？事先留好扩展点以便在未来需求变更的时候不需要改动代码的整体结构，做到在最小代码改动的情况下将新的代码很灵活地插入到扩展点上，做到“对扩展开放、修改关闭”。

还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口扩展一个新的实现来替换掉老的实现即可，上游系统的代码几乎不需要修改。

**在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式。**

```java
// 这一部分体现了抽象意识
public interface MessageQueue {...}
public class KafkaMessageQueue implements MessageQueue {...}
public class RocketMQMessageQueue implements MessageQueue {...}

public interface MessageFormatter {...}
public class JsonMessageFormatter implements MessageFormatter {...}
public class MessageFormatter implements MessageFormatter {...}

public class Demo {
    // 基于接口而非实现编程
    private MessageQueue msgQueue; 
    // 依赖注入
    public Demo(MessageQueue msgQueue) {
        this.msgQueue = msgQueue;
    }

    // msgFormatter：多态、依赖注入
    public void sendNotification(Notification notification, MessageFormatter msgFormatter) {...}
}
```

***如何在项目中灵活应用开闭原则？***

对于一些比较确定的、短期内可能就会扩展的需求，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候再通过重构代码的方式来支持扩展的需求。

而且，开闭原则也并不是免费的，有些情况下代码的扩展性会跟可读性相冲突。

### 17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？

***如何理解“里氏替换原则”？***

If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.

Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.

子类对象（object of subtype / derived class）能够替换程序（program）中父类对象（object of base / parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变，即正确性不被破坏。

```java
// 里氏替换
public class SecurityTransporter extends Transporter {
    @Override
    public Response sendRequest(Request request) {
        if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
            request.addPayload("app-id", appId);
            request.addPayload("app-token", appToken);
        }
        return super.sendRequest(request);
    }
}

public class SecurityTransporter extends Transporter {
    @Override
    public Response sendRequest(Request request) {
        // 程序的逻辑行为有了改变
        if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {
            throw new NoAuthorizationRuntimeException();
        }
        request.addPayload("app-id", appId);
        request.addPayload("app-token", appToken);
        return super.sendRequest(request);
    }
}
```

虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里氏替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候不改变原有程序的逻辑，即不破坏原有程序的正确性。

***哪些代码明显违背了 LSP？***

Design By Contract，按照协议来设计。

父类定义了函数的行为约定，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系也可以替换成接口和实现类之间的关系。

判断子类的设计实现是否违背了里氏替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明子类的设计实现没有完全遵守父类的约定，子类有可能违背了里氏替换原则。

### 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

***如何理解“接口隔离原则”？***

Clients should not be forced to depend upon interfaces that they do not use.

客户端不应该被强迫依赖它不需要的接口，其中的“客户端”可以理解为接口的调用者或者使用者。

***把“接口”理解为一组 API 接口集合***

```java
public interface UserService {
    boolean register(...);
    boolean login(...);
    UserInfo getUserInfoById(...);
    UserInfo getUserInfoByCellphone(...);
}

public class UserServiceImpl implements UserService {
    // ...
}
```

```java
public interface UserService {
    boolean register(...);
    boolean login(...);
    UserInfo getUserInfoById(...);
    UserInfo getUserInfoByCellphone(...);
}

public interface RestrictedUserService {
    boolean deleteUserByCellphone(...);
    boolean deleteUserById(...);
}

public class UserServiceImpl implements UserService, RestrictedUserService {
    // ...
}
```

在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

***把“接口”理解为单个 API 接口或函数***

函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

```java
public class Statistics {
    private Long max;
    private Long min;
    private Long average;
    private Long sum;
    private Long percent99;
    private Long percent999;
    // ...
}

public Statistics count(Collection<Long> dataSet) {
    Statistics statistics = new Statistics();
    // ...
    return statistics;
}
```

```java
public Long max(Collection<Long> dataSet) {...}
public Long min(Collection<Long> dataSet) {...} 
public Long average(Colletion<Long> dataSet) {...}
```

单一职责原则针对的是模块、类、接口的设计，而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考角度不同，它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定，如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

***把“接口”理解为 OOP 中的接口概念***

```java
public class RedisConfig {
    private ConfigSource configSource;
    private String address;
    private int timeout;
    private int maxTotal;
    // ...
    public RedisConfig(ConfigSource configSource) {
        this.configSource = configSource;
    }
    public String getAddress() {
        return this.address;
    }
    // ...
}
public class KafkaConfig {...}
public class MysqlConfig {...}
```

```java
public interface Updater {
    void update();
}
public class RedisConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class KafkaConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class MysqlConfig {...}
public class ScheduledUpdater {
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    private long initialDelayInSeconds;
    private long periodInSeconds;
    private Updater updater;
    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {
        this.updater = updater;
        this.initialDelayInSeconds = initialDelayInSeconds;
        this.periodInSeconds = periodInSeconds;
    }

    public void run() {
        executor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                updater.update();
            }
        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);
    }
}
public class Application {
    ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
    }
}
```

```java
public interface Updater {
    void update();
}
public interface Viewer {
    String outputInPlainText();
    Map<String, String> output();
}
public class RedisConfig implements Updater, Viewer {
    // ...
    @Override
    public void update() {...}
    @Override
    public String outputInPlainText() {...}
    @Override
    public Map<String, String> output() {...}
}
public class KafkaConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class MysqlConfig implements Viewer {
    // ...
    @Override
    public String outputInPlainText() {...}
    @Override
    public Map<String, String> output() {...}
}
public class SimpleHttpServer {
    private String host;
    private int port;
    private Map<String, List<Viewer>> viewers = new HashMap<>();
    public SimpleHttpServer(String host, int port) {...}
    public void addViewers(String urlDirectory, Viewer viewer) {
        if (!viewers.containsKey(urlDirectory)) {
            viewers.put(urlDirectory, new ArrayList<Viewer>());
        }
        this.viewers.get(urlDirectory).add(viewer);
    }
    public void run() {...}
}
public class Application {
    ConfigSource configSource = new ZookeeperConfigSource();
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
        simpleHttpServer.addViewer("/config", redisConfig);
        simpleHttpServer.addViewer("/config", mysqlConfig);
        simpleHttpServer.run();
    }
}
```

我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则。

### 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

***控制反转（IOC）***

框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行，在使用框架之后，整个程序的执行流程可以通过框架来控制，流程的控制权从程序员“反转”到了框架。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

***依赖注入（DI）***

不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

通过依赖注入的方式将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。

***依赖注入框架（DI Framework）***

我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

***依赖反转原则（DIP）***

依赖反转原则也叫作依赖倒置原则，这条原则跟控制反转有点类似，主要用来指导框架层面的设计。

High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

Tomcat 是运行 Java Web 应用程序的容器，我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块，Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

### 20 | 理论六：我为何说 KISS、YAGNI 原则看似简单，却经常被用错？

***如何理解“KISS 原则”？***

Keep It Simple and Stupid.

Keep It Short and Simple.

Keep It Simple and Straightforward.

KISS 原则是保持代码可读和可维护的重要手段，代码足够简单，也就意味着很容易读懂，bug 比较难隐藏，即便出现 bug，修复起来也比较简单。

***代码行数越少就越“简单”吗？***

并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。

***代码逻辑复杂就违背 KISS 原则吗？***

本身就复杂的问题用复杂的方法解决并不违背 KISS 原则。

平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本，在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。

同样的代码在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。

***如何写出满足 KISS 原则的代码？***

不要使用同事可能不懂的技术来实现代码；不要重复造轮子，要善于使用已经有的工具类库；不要过度优化，不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

评判代码是否简单，还有一个很有效的间接方法，那就是 code review。

越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

***YAGNI 跟 KISS 说的是一回事吗？***

You Ain’t Gonna Need It.

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。

KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。

### 21 | 理论七：重复的代码就一定违背 DRY 吗？如何提高代码的复用性？

***DRY 原则（Don’t Repeat Yourself）***

**实现逻辑重复**

尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。

**功能语义重复**

尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。

**代码执行重复**

```java
public class UserService {
    private UserRepo userRepo;
    public User login(String email, String password) {
        // 代码执行重复
        boolean existed = userRepo.checkIfUserExisted(email, password);
        if (!existed) {
            // ...
        }
        User user = userRepo.getUserByEmail(email);
        return user;
    }
}

public class UserRepo {
    public boolean checkIfUserExisted(String email, String password) {
        // 代码执行重复
        if (!EmailValidation.validate(email)) {
            // ...
        }
        if (!PasswordValidation.validate(password)) {
            // ...
        }
        // ...
    }
    public User getUserByEmail(String email) {
        // 代码执行重复
        if (!EmailValidation.validate(email)) {
            // ...
        }
        // ...
    }
}
```

```java
public class UserService {
    private UserRepo userRepo;
    public User login(String email, String password) {
        if (!EmailValidation.validate(email)) {
            // ...
        }
        if (!PasswordValidation.validate(password)) {
            // ...
        }
        User user = userRepo.getUserByEmail(email);
        if (user == null || !password.equals(user.getPassword()) {
            // ...
        }
    }
}

public class UserRepo {
    public boolean checkIfUserExisted(String email, String password) {
        // ...
    }
    public User getUserByEmail(String email) {
        // ...
    }
}
```

***代码复用性（Code Reusability）***

**什么是代码的复用性？**

代码复用表示一种行为，我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力，我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则，不要写重复的代码。

**怎么提高代码复用性？**

*减少代码耦合*

*满足单一职责原则*

*模块化*

*业务与非业务逻辑分离*

*通用代码下沉*

*继承、多态、抽象、封装*

*应用模板等设计模式*

除了上面讲到的这些方法之外，复用意识也非常重要。我们在写代码的时候，要多去思考一下这部分代码是否可以抽取出来作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候要像设计一个外部 API 那样去思考它的复用性。

***辩证思考和灵活应用***

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

### 22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？

***何为“高内聚、松耦合”？***

“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。

在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干，高内聚有助于松耦合，松耦合又需要高内聚的支持。

**什么是“高内聚”？**

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。

**什么是“松耦合”**

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。

***“迪米特法则”理论描述***

它还有另外一个更加达意的名字，叫作最小知识原则。

Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.

Each unit should only talk to its friends; don't talk to strangers.

Only talk to your immediate friends.

**不该有直接依赖关系的类之间，不要有依赖**

```java
public class NetworkTransporter {
    public Byte[] send(HtmlRequest htmlRequest) {
        // ...
    }
}
public class HtmlDownloader {
    private NetworkTransporter transporter;
    public Html downloadHtml(String url) {
        Byte[] rawHtml = transporter.send(new HtmlRequest(url));
        return new Html(rawHtml);
    }
}
public class Document {
    private Html html;
    private String url;
    public Document(String url) {
        this.url = url;
        HtmlDownloader downloader = new HtmlDownloader();
        this.html = downloader.downloadHtml(url);
    }
    // ...
}
```

*NetworkTransporter*

作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。

```java
public class NetworkTransporter {
    public Byte[] send(String address, Byte[] data) {
        // ...
    }
}
```

*HtmlDownloader*

```java
public class HtmlDownloader {
    private NetworkTransporter transporter;
    public Html downloadHtml(String url) {
        HtmlRequest htmlRequest = new HtmlRequest(url);
        Byte[] rawHtml = transporter.send(htmlRequest.getAddress(), htmlRequest.getContent().getBytes());
        return new Html(rawHtml);
    }
}
```

*Document*

构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。

HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。

从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。

```java
public class Document {
    private Html html;
    private String url;
    public Document(String url, Html html) {
        this.html = html;
        this.url = url;
    }
    //...
}
// 通过工厂方法创建 Document
public class DocumentFactory {
    private HtmlDownloader downloader;
    public DocumentFactory(HtmlDownloader downloader) {
        this.downloader = downloader;
    }
    public Document createDocument(String url) {
        Html html = downloader.downloadHtml(url);
        return new Document(url, html);
    }
}
```

**有依赖关系的类之间，尽量只依赖必要的接口**

```java
public class Serialization {
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
```

只用到序列化操作的类不应该依赖反序列化接口，同理，只用到反序列化操作的类不应该依赖序列化接口。

```java
public class Serializer {
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
}
public class Deserializer {
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
```

尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。

```java
public interface Serializable {
    String serialize(Object object);
}
public interface Deserializable {
    Object deserialize(String text);
}
public class Serialization implements Serializable, Deserializable {
    @Override
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
    @Override
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
public class DemoClass_1 {
    private Serializable serializer;
    public Demo(Serializable serializer) {
        this.serializer = serializer;
    }
    //...
}
public class DemoClass_2 {
    private Deserializable deserializer;
    public Demo(Deserializable deserializer) {
        this.deserializer = deserializer;
    }
    //...
}
```

“基于接口而非实现编程”的设计原则结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。

### 23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？

***需求分析***

除了刚刚讲的“借鉴”的思路之外，我还喜欢通过产品的线框图、用户用例（user case）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。

用户用例侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。

***系统设计***

面向对象设计聚焦在代码层面（主要是针对类），系统设计聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。

**合理地将功能划分到不同模块**

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

怎么判断模块划分是否合理呢？实际上，我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。

除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。

**设计模块与模块之间的交互关系**

在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。

比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。

除此之外，上下层系统之间的调用倾向于通过同步接口，同层系统之间的调用倾向于异步消息。

### 24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？

**设计模块的接口、数据库、业务模型**

数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。

***为什么要分 MVC 三层开发？***

**分层能起到代码复用的作用**

同一个 Repository 可能会被多个 Service 调用，同一个 Service 可能会被多个 Controller 调用。

如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。

**分层能起到隔离变化的作用**

分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。

除此之外，Controller、Service、Repository 三层代码的稳定程度不同，引起变化的原因也不同，所以分成三层来组织代码能有效地隔离变化。

**分层能起到隔离关注点的作用**

三层之间的关注点不同，分层之后职责更加分明，更加符合单一职责原则，代码的内聚性更好。

**分层能提高代码的可测试性**

单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repository 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库注入到 Service 层代码中。

**分层能应对系统的复杂性**

拆分有垂直和水平两个方向，水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。

***BO、VO、Entity 存在的意义是什么？***

VO、BO、Entity 并非完全一样；VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的；为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象再继续处理。

### 25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？

***需求分析***

**功能性需求分析**

相对于一大长串的文字描述，人脑更容易理解短的、罗列比较规整的、分门别类的列表信息。

**非功能性需求分析**

易用性；性能；扩展性；容错性；通用性。

***框架设计***

借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见摸得着，比较具体不抽象，能够很有效地帮助我捋清更复杂的设计思路，是迭代设计的基础。

### 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？

***小步快跑、逐步迭代***

我们应该分多个版本逐步完善这个框架，第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0 ... 版本中继续迭代优化。

### 27 | 理论一：什么情况下要重构？到底重构什么？又该如何重构？

***重构的目的：为什么要重构（why）？***

在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，修改设计上的不足，提高代码质量。

首先，重构是时刻保证代码质量的一个极其有效的手段，不至于让代码腐化到无可救药的地步。

其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。

最后，重构是避免过度设计的有效手段。

“初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码”。

***重构的对象：到底重构什么（what）？***

根据重构的规模，我们可以笼统地分为大规模高层次重构和小规模低层次的重构。

大型重构指的是对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等重构，重构的手段有：分层、模块化、解耦、抽象可复用组件等等。这类重构使用的工具就是我们学习过的设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大。

小型重构指的是对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如规范命名、规范注释、消除超大类或函数、提取重复代码等等。小型重构更多的是利用编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小。

***重构的时机：什么时候重构（when）？***

寄希望于在代码烂到一定程度之后集中重构来解决所有问题是不现实的，我们必须探索一条可持续、可演进的方式。

所以，我特别提倡的重构策略是持续重构。

就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。

时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护过程中质量的下降。

***重构的方法：又该如何重构（how）？***

在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后再继续进行下一阶段的重构，保证代码仓库中的代码一直处于可运行、逻辑正确的状态。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。

### 28 | 理论二：为了保证重构不出错，有哪些非常能落地的技术手段？

***什么是单元测试？***

单元测试由研发工程师自己来编写，用来测试自己写的代码的正确性。单元测试相对于集成测试来说，测试的粒度更小一些。集成测试的测试对象是整个系统或者某个功能模块，是一种端到端的测试。而单元测试的测试对象是类或者函数，用来测试一个类或函数是否按照预期的逻辑执行，是代码层级的测试。

***为什么要写单元测试？***

单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 Code Review）。

**单元测试能有效地帮你发现代码中的 bug**

**写单元测试能帮你发现代码设计上的问题**

代码的可测试性是评判代码质量的一个重要标准。

**单元测试是对集成测试的有力补充**

**写单元测试的过程本身就是代码重构的过程**

设计和实现代码的时候，我们很难把所有的问题都想清楚，而编写单元测试就相当于对代码进行一次自我 Code Review，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。

**阅读单元测试能帮助你快速熟悉代码**

阅读代码最有效的手段，就是先了解它的业务背景和设计思路，然后再去看代码，这样代码读起来就会轻松很多。

单元测试用例实际上就是用户用例，反映了代码的功能和如何使用。借助单元测试，我们不需要深入地阅读代码便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。

**单元测试是 TDD 可落地执行的改进方案**

单元测试正好是对 TDD 的一种改进方案，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题再回过头去重构代码。

***如何编写单元测试？***

写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。

**写单元测试真的是件很耗时的事情吗？**

我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。

**对单元测试的代码质量有什么要求吗？**

相对于被测代码，我们对单元测试代码的质量可以放低一些要求。

**单元测试只要覆盖率高就够了吗？**

不管覆盖率的计算方式如何高级，将覆盖率作为衡量单元测试质量的唯一标准是不合理的。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况。

从过往的经验来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。

**写单元测试需要了解代码的实现逻辑吗？**

单元测试不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能。

**如何选择单元测试框架？**

写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。

***单元测试为何难落地执行？***

对于程序员这个具有很强学习能力的群体来说，学会如何写单元测试并不是一件难事，难的是能够真正感受到它的作用，并且打心底认可能 100% 落地执行。

### 29 | 理论三：什么是代码的可测试性？如何写出可测试性好的代码？

***编写可测试代码案例实战***

单例相当于一个全局变量，我们无法 mock（无法继承和重写方法），也无法通过依赖注入的方式替换。

```java
public class Transaction {
    public boolean execute() {
    // ...
    boolean isLocked = false;
    try {
        isLocked = RedisDistributedLock.getSingletonIntance().lockTransction(id);
        // ...
    } finally {
        if (isLocked) {
            RedisDistributedLock.getSingletonIntance().unlockTransction(id);
        }
    }
}
```

我们可以对 Transaction 上锁这部分逻辑重新封装一下。

```java
public class TransactionLock {
    public boolean lock(String id) {
        return RedisDistributedLock.getSingletonIntance().lockTransction(id);
    }
    public void unlock() {
        RedisDistributedLock.getSingletonIntance().unlockTransction(id);
    }
}

public class Transaction {
    // ...
    private TransactionLock lock;
    public void setTransactionLock(TransactionLock lock) {
        this.lock = lock;
    }
    public boolean execute() {
        // ...
        try {
            isLocked = lock.lock();
            //...
        } finally {
            if (isLocked) {
                lock.unlock();
            }
        }
    }
}
```

代码中包含跟“时间”有关的“未决行为”逻辑，我们一般的处理方式是将这种未决行为逻辑重新封装。

```java
public class Transaction {
    protected boolean isExpired() {
        long executionInvokedTimestamp = System.currentTimestamp();
        return executionInvokedTimestamp - createdTimestamp > 14days;
    }
    public boolean execute() throws InvalidTransactionException {
        // ...
        if (isExpired()) {
            this.status = STATUS.EXPIRED;
            return false;
        }
        //...
    }
}
```

```java
public void testExecute_with_TransactionIsExpired() {
    // ...
    Transction transaction = new Transaction(null, buyerId, sellerId, productId, orderId) {
        protected boolean isExpired() {
            return true;
        }
    };
    boolean actualResult = transaction.execute();
    assertFalse(actualResult);
    assertEquals(STATUS.EXPIRED, transaction.getStatus());
}
```

***常见的 Anti-Patterns***

**未决行为**

所谓的未决行为逻辑就是指代码的输出是随机或者不确定的，比如跟时间、随机数有关的代码。

**全局变量**

`private static AtomicInteger position = new AtomicInteger(0);`

全局变量是一种面向过程的编程风格，有种种弊端，实际上，滥用全局变量也让编写单元测试变得困难。

**静态方法**

静态方法跟全局变量一样，也是一种面向过程的编程思维，在代码中调用静态方法有时会导致代码不易测试，主要原因是静态方法也很难 mock。

**复杂继承**

如果父类需要 mock 某个依赖对象才能进行单元测试，那所有的子类、子类的子类等等在编写单元测试的时候都要 mock 这个依赖对象。

**高耦合代码**

如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候可能需要 mock 这十几个依赖的对象。

### 30 | 理论四：如何通过封装、抽象、模块化、中间层等解耦代码？

***“解耦”为何如此重要？***

软件设计与开发最重要的工作之一就是应对复杂性。人处理复杂性的能力是有限的，过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说重构是保证代码质量不至于腐化到无可救药地步的有效手段，那么利用解耦的方法对代码重构，就是保证代码不至于复杂到无法控制的有效手段。

不管是阅读代码还是修改代码，“高内聚、松耦合”的特性可以让我们聚焦在某一模块或类中，不需要了解太多其他模块或类，让我们的焦点不至于过于发散，降低了阅读和修改代码的难度。而且，因为依赖关系简单，耦合小，修改代码不至于牵一发而动全身，代码改动比较集中，引入 bug 的风险也就减少了很多。同时，“高内聚、松耦合”的代码可测试性也更加好，容易 mock 或者很少需要 mock 外部依赖的模块或者类。

***代码是否需要“解耦”？***

间接的衡量标准有很多，比如，看修改代码会不会牵一发而动全身。

把模块与模块之间、类与类之间的依赖关系画出来，根据依赖关系图的复杂性来判断是否需要解耦重构。

***如何给代码“解耦”？***

**封装与抽象**

封装和抽象可以有效地隐藏实现的复杂性，隔离实现的易变性，给依赖的模块提供稳定且易用的抽象接口。

**中间层**

**模块化**

如果追本溯源，模块化思想更加本质的东西就是分而治之。

**其他设计思想和原则**

单一职责原则，基于接口而非实现编程，依赖注入，多用组合少用继承，迪米特法则

### 31 | 理论五：让你最快速地改善代码质量的 20 条编程规范（上）

***命名***

**命名多长最合适？**

在我看来，尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长。在代码列长度有限制的情况下，就会经常出现一条语句被分割成两行的情况，这其实会影响代码可读性。

实际上，在足够表达其含义的情况下，命名当然是越短越好。但是，大部分情况下，短的命名都没有长的命名更能达意。所以，很多书籍或者文章都不推荐在命名时使用缩写。对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，对于类名这种作用域比较大的，我更推荐用长的命名方式。

**利用上下文简化命名**

```java
public class User {
    // private String userName;
    private String name;
    // ...
}
```

```java
// public void uploadUserAvatarImageToAliyun(String userAvatarImageUri);
public void uploadUserAvatarImageToAliyun(String imageUri);
```

**命名要可读、可搜索**

我这里所说的“可读”，指的是不要用一些特别生僻、难发音的英文单词来命名。

我们在 IDE 中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。所以，我们在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，统一规约是很重要的，能减少很多不必要的麻烦。

**如何命名接口和抽象类？**

IUserService 对应实现类 UserService，UserService 对应的实现类加后缀 Impl。

一种是带上前缀 Abstract，另一种是不带前缀。

实际上，对于接口和抽象类，选择哪种命名方式都是可以的，只要项目里能够统一就行。

***注释***

命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，注释就是一个很好的补充。

**注释到底该写什么？**

注释的目的就是让代码更容易看懂，只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。

*注释比代码承载的信息更多（做什么）*

命名的主要目的是解释“做什么”，但是，对于类来说包含的信息比较多，一个简单的命名就不够全面详尽了。这个时候，在注释中写明“做什么”就合情合理了。

*注释起到总结性作用、文档的作用（怎么做、如何用）*

在注释中，关于具体的代码实现思路，我们可以写一些总结性的说明、特殊情况的说明。这样能够让阅读代码的人通过注释就能大概了解代码的实现思路，阅读起来就会更加容易。

实际上，对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”，举一些简单的 quick start 的例子，让使用者在不阅读代码的情况下快速地知道该如何使用。

*一些总结性注释能让代码结构更清晰*

对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理。

```java
// step1 ...
// step2 ...
```

**注释是不是越多越好？**

按照我的经验来说，类和函数一定要写注释，而且要写得尽可能全面详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。

### 32 | 理论五：让你最快速地改善代码质量的 20 条编程规范（中）

***类、函数多大才合适？***

对于函数代码行数的最大限制，网上有一种说法，那就是不要超过一个显示屏的垂直高度。

当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数过多了。

***一行代码多长最合适？***

总体上来讲我们要遵循的一个原则是：一行代码最长不能超过 IDE 显示的宽度。

***善用空行分割单元块***

对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，我们还可以使用空行来分割各个代码块。

除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式让这些不同模块的代码界限更加明确。

***四格缩进还是两格缩进？***

还有一个选择的标准，那就是跟业内推荐的风格统一、跟著名开源项目统一。

除此之外，值得强调的是不管用两格缩进还是四格缩进，一定不要用 tab 键缩进。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。

***大括号是否要另起一行？***

大括号跟上一条语句在同一行还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，没有绝对的优劣之分。

***类中成员的排列顺序***

在 Java 类文件中，先要书写类所属的包名，然后再罗列 import 引入的依赖类。在 Google 编码规范中，依赖类按照字母序从小到大排列。

在类中，成员变量排在函数的前面，成员变量之间或函数之间都是按照“先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）”的方式来排列的。除此之外，成员变量之间或函数之间还会按照作用域范围从大到小的顺序来排列，先写 public 成员变量或函数，然后是 protected，最后是 private。

实际上，还有另外一种排列习惯，那就是把有调用关系的函数放到一块。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块。

### 33 | 理论五：让你最快速地改善代码质量的 20 条编程规范（下）

***把代码分割成更小的单元块***

大部分人阅读代码的习惯都是先看整体再看细节，所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，只有代码逻辑比较复杂的时候才建议提炼类或者函数，毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候还得跳过去看一下，这样反倒增加了阅读成本。

***避免函数参数过多***

考虑函数是否职责单一，是否能通过拆分成多个函数的方式来减少参数。

将函数的参数封装成对象。

除此之外，如果函数是对外暴露的远程接口，将参数封装成对象还可以提高接口的兼容性。

***勿用函数参数来控制逻辑***

不要在函数中使用布尔类型的标识参数来控制内部逻辑，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则，我建议将其拆成两个函数，可读性上也要更好。

不过，如果函数是 private 私有函数，影响范围有限，或者拆分之后的两个函数经常同时被调用，我们可以酌情考虑保留标识参数。

除了布尔类型作为标识参数来控制逻辑的情况外，还有一种“根据参数是否为 null”来控制逻辑的情况。针对这种情况，我们也应该将其拆分成多个函数，拆分之后的函数职责更明确，不容易用错。

***函数设计要职责单一***

相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。

***移除过深的嵌套层次***

我个人建议，嵌套最好不超过两层，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进导致嵌套内部的语句超过一行的长度而折成两行，影响代码的整洁。

去掉多余的 if 或 else 语句；使用编程语言提供的 continue、break、return 关键字提前退出嵌套；调整执行顺序来减少嵌套；将部分嵌套逻辑封装成函数调用来减少嵌套。

***学会使用解释性变量***

常量取代魔法数字；使用解释性变量来解释复杂表达式。

### 34 | 实战一（上）：通过一段 ID 生成器代码，学习如何发现代码质量问题

***如何发现代码质量问题？***

**常规 checklist**

目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？

是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？

设计模式是否应用得当？是否有过度设计？

代码是否容易扩展？如果要添加新功能，是否容易实现？

代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？

代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？

代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？

**业务需求 checklist**

代码是否实现了预期的业务需求？

逻辑是否正确？是否处理了各种异常情况？

日志打印是否得当？是否方便 debug 排查问题？

接口是否易用？是否支持幂等、事务等？

代码是否存在并发问题？是否线程安全？

性能是否有优化空间，比如，SQL、算法是否可以优化？

是否有安全漏洞？比如输入输出校验是否全面？

### 35 | 实战一（下）：手把手带你将 ID 生成器代码从“能用”重构为“好用”

***第一轮重构：提高代码的可读性***

***第二轮重构：提高代码的可测试性***

依赖注入之所以能提高代码可测试性，主要是因为通过这样的方式能轻松地用 mock 对象替换依赖的真实对象。那我们为什么要 mock 这个对象呢？这是因为这个对象参与逻辑执行（比如，我们要依赖它输出的数据做后续的计算）但又不可控。

***第三轮重构：编写完善的单元测试***

***第四轮重构：添加注释***

### 36 | 实战二（上）：程序出错该返回啥？NULL、异常、错误码、空对象？

***返回错误码***

C 语言中没有异常这样的语法机制，因此，返回错误码便是最常用的出错处理方式。而在 Java、Python 等比较新的编程语言中，大部分情况下，我们都用异常来处理函数出错的情况，极少会用到错误码。

***返回 NULL 值***

在多数编程语言中，我们用 NULL 来表示“不存在”这种语义。

如果某个函数有可能返回 NULL 值，我们在使用它的时候忘记了做 NULL 值判断，就有可能会抛出空指针异常。

如果我们定义了很多返回值可能为 NULL 的函数，那代码中就会充斥着大量的 NULL 值判断逻辑，一方面写起来比较繁琐，另一方面它们跟正常的业务逻辑耦合在一起，会影响代码的可读性。

尽管返回 NULL 值有诸多弊端，但对于以 get、find、select、search、query 等单词开头的查找函数来说，数据不存在并非是一种异常情况，这是一种正常行为。所以，返回代表不存在语义的 NULL 值比返回异常更加合理。

对于查找数据不存在的情况，函数到底该用 NULL 值还是异常，有一个比较重要的参考标准，看项目中其他类似的查找函数都是如何定义的，只要整个项目遵从统一的约定即可。

***返回空对象***

当函数返回的数据是字符串类型或者集合类型的时候，我们可以用空字符串或空集合替代 NULL 值，来表示不存在的情况。

***抛出异常对象***

异常可以携带更多的错误信息，比如函数调用栈信息。除此之外，异常可以将正常逻辑和异常逻辑的处理分离开来，这样代码的可读性就会更好。

对于代码 bug（比如数组越界）以及不可恢复异常（比如数据库连接失败），即便我们捕获了也做不了太多事情，所以，我们倾向于使用非受检异常。对于可恢复异常、业务异常（比如提现金额大于余额的异常），我们更倾向于使用受检异常，明确告知调用者需要捕获处理。

**很多人主张所有的异常情况都应该使用非受检异常**

受检异常需要显式地在函数定义中声明。如果函数会抛出很多受检异常，那函数的定义就会非常冗长，这就会影响代码的可读性，使用起来也不方便。

编译器强制我们必须显示地捕获所有的受检异常，代码实现会比较繁琐。而非受检异常正好相反，我们不需要在定义中显示声明，并且是否需要捕获处理，也可以自由决定。

受检异常的使用违反开闭原则。如果我们给某个函数新增一个受检异常，这个函数所在的函数调用链上的所有位于其之上的函数都需要做相应的代码修改，直到调用链中的某个函数将这个新增的异常 try-catch 处理掉为止。而新增非受检异常可以不改动调用链上的代码，我们可以灵活地选择在某个函数中集中处理，比如在 Spring 中的 AOP 切面中集中处理异常。

**非受检异常也有弊端，它的优点其实也正是它的缺点**

过于灵活会带来不可控，非受检异常不需要显式地在函数定义中声明，那我们在使用函数的时候就需要查看代码才能知道具体会抛出哪些异常。非受检异常不需要强制捕获处理，那程序员就有可能漏掉一些本应该捕获处理的异常。

**如何处理函数抛出的异常？**

*直接吞掉*

*原封不动地 re-throw*

*包装成新的异常 re-throw*

是否往上继续抛出，要看上层代码是否关心这个异常，关心就将它抛出，否则就直接吞掉。是否需要包装成新的异常抛出，要看上层代码是否能理解这个异常、是否业务相关，如果能理解且业务相关就可以直接抛出，否则就封装成新的异常抛出。

### 37 | 实战二（下）：重构 ID 生成器项目中各函数的异常处理代码

***重构 generate() 函数***

```java
public String generate() throws IdGenerationFailureException {
    String substrOfHostName = getLastFieldOfHostName();
    if (substrOfHostName == null || substrOfHostName.isEmpty()) {
      throw new IdGenerationFailureException("host name is empty.");
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s", substrOfHostName, currentTimeMillis, randomString);
    return id;
}
```

***重构 getLastFieldOfHostName() 函数***

```java
private String getLastFieldOfHostName() throws UnknownHostException {
    String hostName = InetAddress.getLocalHost().getHostName();
    String substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
}
```

getLastFieldOfHostName() 函数用来获取主机名的最后一个字段，UnknownHostException 异常表示主机名获取失败，两者算是业务相关，所以可以直接将 UnknownHostException 抛出，不需要重新包裹成新的异常。

```java
public String generate() throws IdGenerationFailureException {
    String substrOfHostName = null;
    try {
      substrOfHostName = getLastFieldOfHostName();
    } catch (UnknownHostException e) {
      throw new IdGenerationFailureException("host name is empty.");
    }
    long currentTimeMillis = System.currentTimeMillis();
    String randomString = generateRandomAlphameric(8);
    String id = String.format("%s-%d-%s", substrOfHostName, currentTimeMillis, randomString);
    return id;
  }
```

在 generate() 函数中，我们需要捕获 UnknownHostException 异常，并重新包裹成新的异常 IdGenerationFailureException 往上抛出。

调用者在使用 generate() 函数的时候，只需要知道它生成的是随机唯一 ID，并不关心 ID 是如何生成的。也就说是，这是依赖抽象而非实现编程。如果 generate() 函数直接抛出 UnknownHostException 异常，实际上是暴露了实现细节。

从代码封装的角度来讲，我们不希望将 UnknownHostException 这个比较底层的异常暴露给更上层的代码，也就是调用 generate() 函数的代码。而且，调用者拿到这个异常的时候，并不能理解这个异常到底代表了什么，也不知道该如何处理。

UnknownHostException 异常跟 generate() 函数在业务上没有相关性。

***重构 getLastSubstrSplittedByDot() 函数***

如果函数是 private 类私有的，只在类内部被调用，完全在你自己的掌控之下，自己保证在调用这个 private 函数的时候不要传递 NULL 值或空字符串就可以了。所以，我们可以不在 private 函数中做 NULL 值或空字符串的判断。如果函数是 public 的，你无法掌控会被谁调用以及如何调用，为了尽可能提高代码的健壮性，我们最好是在 public 函数中做 NULL 值或空字符串的判断。

单元测试可能要测试一些 corner case，比如输入是 NULL 值或者空字符串的情况。所以，这里我们最好也加上 NULL 值或空字符串的判断逻辑。虽然加上有些冗余，但多加些检验总归不会错的。

```java
@VisibleForTesting
protected String getLastSubstrSplittedByDot(String hostName) {
    if (hostName == null || hostName.isEmpty()) {
      throw IllegalArgumentException("..."); // 运行时异常
    }
    String[] tokens = hostName.split("\\.");
    String substrOfHostName = tokens[tokens.length - 1];
    return substrOfHostName;
}
```

我们在使用这个函数的时候，自己也要保证不传递 NULL 值或者空字符串进去。

```java
private String getLastFieldOfHostName() throws UnknownHostException{
    String hostName = InetAddress.getLocalHost().getHostName();
    if (hostName == null || hostName.isEmpty()) { // 此处做判断
      throw new UnknownHostException("...");
    }
    String substrOfHostName = getLastSubstrSplittedByDot(hostName);
    return substrOfHostName;
}
```

***重构 generateRandomAlphameric() 函数***

生成一个长度为负值的随机字符串是不符合常规逻辑的，是一种异常行为，所以，当传入的参数 length < 0 的时候，我们抛出 IllegalArgumentException 异常。

length = 0 是否是异常行为呢？这就看你自己怎么定义了。我们既可以把它定义为一种异常行为，抛出 IllegalArgumentException 异常，也可以把它定义为一种正常行为，让函数在入参 length = 0 的情况下直接返回空字符串。不管选择哪种处理方式，最关键的一点是，要在函数注释中明确告知 length = 0 的情况下会返回什么样的数据。

### 38 | 总结回顾面向对象、设计原则、编程规范、重构技巧等知识点

***一、代码质量评判标准***

**如何评价代码质量的高低？**

代码质量的评价有很强的主观性，描述代码质量的词汇也有很多，比如可读性、可维护性、灵活、优雅、简洁，这些词汇是从不同的维度去评价代码质量的。

**最常用的评价标准有哪几个？**

可维护性、可读性、可扩展性又是提到最多的、最重要的三个评价标准。

**如何才能写出高质量的代码？**

这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

***二、面向对象***

**面向对象概述**

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

**面向对象四大特性**

封装也叫做信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方法来访问内部信息或者数据。它需要编程语言提供权限访问控制语法来支持。封装特性存在的意义，一方面是保护数据不被随意修改，提高代码的可维护性；另一方面是仅暴露有限的必要接口，提高类的易用性。

抽象就是讲如何隐藏方法的具体实现，让使用者只需要关心方法提供了哪些功能，不需要知道这些功能是如何实现的。抽象可以通过接口类或者抽象类来实现。抽象存在的意义，一方面是修改实现不需要改变定义；另一方面是处理复杂系统的有效手段，能有效地过滤掉不必要关注的信息。

继承用来表示类之间的 is-a 关系，分为两种模式：单继承和多继承。为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持。继承主要是用来解决代码复用的问题。

多态是指子类可以替换父类，在实际的代码运行过程中调用子类的方法实现。多态这种特性也需要编程语言提供特殊的语法机制来实现。多态可以提高代码的扩展性和复用性，是很多设计模式、设计原则、编程技巧的代码实现基础。

**面向对象 VS 面向过程**

面向对象编程相比面向过程编程的优势主要有三个：

对于大规模复杂程序的开发，程序的处理流程并非单一的一条主线，而是错综复杂的网状结构。面向对象编程比起面向过程编程更能应对这种复杂类型的程序开发。

面向对象编程相比面向过程编程具有更加丰富的特性（封装、抽象、继承、多态）。利用这些特性编写出来的代码，更加易扩展、易复用、易维护。

从编程语言跟机器打交道方式的演进规律中，我们可以总结出：面向对象编程语言比起面向过程编程语言更加人性化、更加高级、更加智能。

不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。只要我们能避免面向过程编程风格的一些弊端，控制好它的副作用，在掌控范围内为我们所用，我们就大可不用避讳在面向对象编程中写面向过程风格的代码。

**面向对象分析、设计与编程**

面向对象分析（OOA）、面向对象设计（OOD）、面向对象编程（OOP）是面向对象开发的三个主要环节。简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。

需求分析的过程实际上是一个不断迭代优化的过程。我们不要试图一下就给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化。这样一个思考过程能让我们摆脱无从下手的窘境。

面向对象设计和实现要做的事情就是把合适的代码放到合适的类中。至于到底选择哪种划分方法，判定的标准是让代码尽量地满足“松耦合、高内聚”、单一职责、对扩展开放对修改关闭等我们之前讲到的各种设计原则和思想，尽量地做到代码可复用、易读、易扩展、易维护。

在面向对象设计这一环节中，我们将需求描述转化为具体类的设计，这个环节的工作可以拆分为下面四个部分：

*划分职责进而识别出有哪些类*

根据需求描述，我们把其中涉及的功能点一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否归为同一个类。

*定义类及其属性和方法*

我们识别出需求描述中的动词，作为候选的方法，再进一步过滤筛选出真正的方法，把功能点中涉及的名词，作为候选属性，然后同样再进行过滤筛选。

*定义类与类之间的交互关系*

我们从更加贴近编程的角度，对类与类之间的关系做了调整，保留了四个关系：泛化、实现、组合、依赖。

*将类组装起来并提供执行入口*

通过这个入口，我们能触发整个代码跑起来。

**接口 VS 抽象类**

**基于接口而非实现编程**

**多用组合少用继承**

**贫血模型 VS 充血模型**