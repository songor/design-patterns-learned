# 设计模式之美

### 开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！

### 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？

### 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

***如何评价代码质量的高低？***

代码质量高低是一个综合各种因素得到的结论，我们并不能通过单一的维度去评价一段代码的好坏。

不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。而且，各种评价维度也不是非黑即白的。

对一段代码的质量评价，常常有很强的主观性。

***最常用的评价标准有哪几个？***

**可维护性（maintainability）**

我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

***可读性（readability）***

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时有很多疑问，那就说明你的代码可读性有待提高了。

**可扩展性（extensibility）**

说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

**灵活性（flexibility）**

**简洁性（simplicity）**

实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。

**可复用性（reusability）**

**可测试性（testability）**

代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。

***如何才能写出高质量的代码？***

问如何写出高质量的代码，也就等同于在问如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

### 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

***面向对象***

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

***设计原则***

对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。

***设计模式***

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。

这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

***编程规范***

***代码重构***

不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

***五者之间的联系***

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。

### 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？

***什么是面向对象编程和面向对象编程语言？***

面向对象编程是一种编程范式或编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石 。

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

***如何判定某编程语言是否是面向对象编程语言？***

我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制、是否完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。

***什么是面向对象分析和面向对象设计？***

分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。

简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。

### 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

***封装（Encapsulation）***

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持，这个语法机制就是访问权限控制。

**封装的意义是什么？它能解决什么编程问题？**

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解，而这对于调用者来说也是一种负担。

***抽象（Abstraction）***

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制来实现抽象这一特性。

类的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档了解其提供了什么功能，就可以直接使用了。

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制就可以实现抽象特性，所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。

**抽象的意义是什么？它能解决什么编程问题？**

在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放，对修改关闭）、代码解耦（降低代码的耦合性）等。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候不用去修改其定义。

***继承（Inheritance）***

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承。

**继承存在的意义是什么？它能解决什么编程问题？**

继承最大的一个好处就是代码复用。不过，这并不是继承所独有的，我们可以通过其他方式来解决代码复用的问题，比如利用组合关系而不是继承关系。

猫属于哺乳动物，从人类认知的角度上来说是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

***多态（Polymorphism）***

多态是指子类可以替换父类，在实际的代码运行过程中调用子类的方法实现。

**多态特性的实现方式**

利用继承加方法重写

利用接口类语法

利用 duck-typing 语法

**多态特性存在的意义是什么？它能解决什么编程问题？**

多态特性能提高代码的可扩展性和复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等等。

### 06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？

***什么是面向过程编程与面向过程编程语言？***

面向过程编程是一种编程范式或编程风格，它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

面向过程编程语言最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。

***面向对象编程相比面向过程编程有哪些优势？***

**OOP 更加能够应对大规模复杂程序的开发**

因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线，如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法就会比较吃力。

面向对象编程以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候思路更加清晰。

类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

**OOP 风格的代码更易复用、易扩展、易维护**

面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。

**OOP 语言更加人性化、更加高级、更加智能**

在进行面向对象编程时候，我们是在思考如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。

### 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

***哪些代码设计看似是面向对象，实际是面向过程的？***

**滥用 getter、setter 方法**

它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。

在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的危险。

**滥用全局变量和全局方法**

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。

大而全的 Constants 类

影响代码的可维护性；增加代码的编译时间，每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间；影响代码的复用性。

将 Constants 类拆解为功能更加单一的多个类；不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中，这样也提高了类设计的内聚性和代码的复用性。

Utils 类

仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。

**定义数据和方法分离的类**

一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中，这就是典型的面向过程的编程风格。

***在面向对象编程中，为什么容易写出面向过程风格的代码？***

你在生活中去完成一个任务，一般都会思考应该先做什么后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反，它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来完成整个任务。

在面向对象编程中，类的设计还是挺需要技巧的，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。

***面向过程编程及面向过程编程语言就真的无用武之地了吗？***

如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主数据为辅，那脚本式的面向过程的编程风格就更适合一些。

面向对象和面向过程两种编程风格也并不是非黑即白、完全对立的。不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。

### 08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？

***什么是抽象类和接口？区别在哪里？***

**抽象类**

抽象类不允许被实例化，只能被继承。

抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现，不包含代码实现的方法叫作抽象方法。

子类继承抽象类，必须实现抽象类中的所有抽象方法。

**接口**

接口不能包含属性（也就是成员变量）。

接口只能声明方法，方法不能包含代码实现。

类实现接口的时候，必须实现接口中声明的所有方法。

**区别**

继承关系是一种 is-a 的关系，抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

***抽象类和接口能解决什么编程问题？***

**我们为什么需要抽象类？它能够解决什么编程问题？**

```java
public class Logger {
    protected boolean isLoggable() {...}
}
public class FileLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。

```java
Logger logger = new FileLogger();
// 编译错误
logger.log(Level.ERROR, "");
```

```java
public class Logger {
    protected boolean isLoggable() {...}
    public void log(Level level, String mesage) {}
}
public class FileLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路能用，但是，它显然没有通过抽象类的实现思路优雅：

在 Logger 中定义一个空的方法，会影响代码的可读性。

当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。

Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法，这也增加了类被误用的风险。

**我们为什么需要接口？它能够解决什么编程问题？**

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。

接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

***如何决定该用抽象类还是接口？***

如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就使用抽象类；如果我们要表示一种 has-a 的关系，并且为了解决抽象而非代码复用的问题，我们就使用接口。

从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

### 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

***如何解读“基于接口而非实现编程”中的“接口”二字？***

从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。

如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。

应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计不仅能应对当下的需求，而且在将来需求发生变化的时候仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

***如何将这条原则应用到实战中？***

```java
public class AliyunImageStore {
    public void createBucketIfNotExisting(String bucketName) {...}
    public String generateAccessToken() {...}
    public String uploadToAliyun(Image image, String bucketName, String accessToken) {...}
    public Image downloadFromAliyun(String url, String accessToken) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        AliyunImageStore imageStore = new AliyunImageStore();
        imageStore.createBucketIfNotExisting(BUCKET_NAME);
        String accessToken = imageStore.generateAccessToken();
        imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
    }
}
```

新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法在 PrivateImageStore 类中都逐一定义并重新实现一遍。

**“魔鬼细节”**

AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。而我们把这种包含“aliyun”字眼的方法照抄到 PrivateImageStore 类中显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。

将图片存储到阿里云的流程跟存储到私有云的流程可能并不是完全一致的。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。

**“基于接口而非实现编程”**

函数的命名不能暴露任何实现细节。

封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法给调用者使用。

为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传（或下载）功能协议。使用者依赖接口，而不是具体的实现类来编程。

```java
public interface ImageStore {
    String upload(Image image, String bucketName);
    Image download(String url);
}

public class AliyunImageStore implements ImageStore {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        String accessToken = generateAccessToken();
        ...
    }
    public Image download(String url) {
        String accessToken = generateAccessToken();
        ...
    }
    private void createBucketIfNotExisting(String bucketName) {...}
    private String generateAccessToken() {...}
}

public class PrivateImageStore implements ImageStore  {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        ...
    }
    public Image download(String url) {...}
    private void createBucketIfNotExisting(String bucketName) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        ImageStore imageStore = new PrivateImageStore();
        imagestore.upload(image, BUCKET_NAME);
    }
}
```

我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节，接口的定义只表明做什么而不是怎么做。而且，在设计接口的时候，我们要多思考一下这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候不需要任何接口定义的改动。

***是否需要为每个类定义接口？***

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。

### 10 | 理论七：为何说要多用组合少用继承？如何决定该用组合还是继承？

***为什么不推荐使用继承？***

鸟类 / 是否会飞 / 是否会叫 / 是否会下蛋 ...

继承层次过深、继承关系过于复杂会影响到代码的可读性和可维护性。

***组合相比继承有哪些优势？***

实际上，我们可以利用组合、接口、委托这三个技术手段来解决继承存在的问题。

```java
public interface EggLayable {
    void layEgg();
}
// 解决代码重复的问题
public class EggLayAbility implements EggLayable {
    @Override
    public void layEgg() {...}
}
public class Ostrich implements Tweetable, EggLayable {
    private TweetAbility tweetAbility = new TweetAbility();
    // 组合
    private EggLayAbility eggLayAbility = new EggLayAbility();
    @Override
    public void tweet() {
        tweetAbility.tweet();
    }
    @Override
    public void layEgg() {
        // 委托
        eggLayAbility.layEgg();
    }
}
```

***如何判断该用组合还是继承？***

继承改写成组合意味着要做更细粒度的类的拆分，这也就意味着我们要定义更多的类和接口，类和接口的增多也就或多或少地增加代码的复杂程度和维护成本。

如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承。

除此之外，还有一些设计模式会固定使用继承或者组合。比如，装饰者模式（decorator pattern）、策略模式（strategy pattern）、组合模式（composite pattern）等都使用了组合关系，而模板模式（template pattern）使用了继承关系。

有的时候，从业务含义上，A 类和 B 类并不一定具有继承关系，仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。这个时候，使用组合就更加合理、更加灵活。

如果你不能改变一个函数的入参类型，而入参又非接口，为了支持多态，只能采用继承来实现。

```java
public class FeignClient {
    public void encode(String url) {...}
}

public void demofunction(FeignClient feignClient) {
    //...
    feignClient.encode(url);
    //...
}

public class CustomizedFeignClient extends FeignClient {
    @Override
    public void encode(String url) {...}
}

// 调用
FeignClient client = new CustomizedFeignClient();
demofunction(client);
```

### 11 | 实战一（上）：业务开发常用的基于贫血模型的 MVC 架构违背 OOP 吗？

***什么是基于贫血模型的传统开发模式？***

Service 层的数据和业务逻辑被分割到 BO 和 Service 两个类中，像 UserBo 这样只包含数据不包含业务逻辑的类就叫作贫血模型（Anemic Domain Model）。这种贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格。

***什么是基于充血模型的 DDD 开发模式？***

**什么是充血模型？**

充血模型（Rich Domain Model），数据和对应的业务逻辑被封装到同一个类中。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。

**什么是领域驱动设计？**

领域驱动设计（即 DDD）主要是用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互。

做好领域驱动设计的关键是看你对自己所做业务的熟悉程度，而不是对领域驱动设计这个概念本身的掌握程度。

**基于充血模型的 DDD 开发模式**

实际上，基于充血模型的 DDD 开发模式实现的代码也是按照 MVC 三层架构分层的，Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。

在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑，业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分，Domain 就相当于贫血模型中的 BO，不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑，而 Service 类变得非常单薄。总结一下的话就是，基于贫血模型的传统开发模式重 Service 轻 BO；基于充血模型的 DDD 开发模式轻 Service 重 Domain。

***为什么基于贫血模型的传统开发模式如此受欢迎？***

第一点原因是，大部分情况下，我们开发的系统业务可能都比较简单，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义。

第二点原因是，充血模型的设计要比贫血模型更加有难度。因为充血模型是一种面向对象的编程风格，我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑，而不是像贫血模型那样只需要定义数据，之后有什么功能开发需求就在 Service 层定义什么操作，不需要事先做太多设计。

第三点原因是，思维已固化，转型有成本。

***什么项目应该考虑使用基于充血模型的 DDD 开发模式？***

在基于充血模型的 DDD 开发模式下，我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法。领域模型相当于可复用的业务中间层，新功能需求的开发都基于之前定义好的这些领域模型来完成。

我们知道，越复杂的系统对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式正好需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发。

### 12 | 实战一（下）：如何利用基于充血模型的 DDD 开发一个虚拟钱包系统？

```java
public class VirtualWallet {
    private Long id;
    private Long createTime = System.currentTimeMillis();
    private BigDecimal balance = BigDecimal.ZERO;
    private boolean isAllowedOverdraft = true;
    private BigDecimal overdraftAmount = BigDecimal.ZERO;
    private BigDecimal frozenAmount = BigDecimal.ZERO;
    public VirtualWallet(Long preAllocatedId) {
        this.id = preAllocatedId;
    }
    public void freeze(BigDecimal amount) {...}
    public void unfreeze(BigDecimal amount) {...}
    public void increaseOverdraftAmount(BigDecimal amount) {...}
    public void decreaseOverdraftAmount(BigDecimal amount) {...}
    public void closeOverdraft() {...}
    public void openOverdraft() {...}
    public BigDecimal balance() {
        return this.balance;
    }
    public BigDecimal getAvaliableBalance() {
        BigDecimal totalAvaliableBalance = this.balance.subtract(this.frozenAmount);
        if (isAllowedOverdraft) {
            totalAvaliableBalance += this.overdraftAmount;
        }
        return totalAvaliableBalance;
    }
    public void debit(BigDecimal amount) {
        BigDecimal totalAvaliableBalance = getAvaliableBalance();
        if (totoalAvaliableBalance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException(...);
        }
        this.balance.subtract(amount);
    }
    public void credit(BigDecimal amount) {
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new InvalidAmountException(...);
        }
        this.balance.add(amount);
    }
}

public class VirtualWalletService {
    private VirtualWalletRepository walletRepo;
    private VirtualWalletTransactionRepository transactionRepo;
    public VirtualWallet getVirtualWallet(Long walletId) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        return wallet;
    }
    public BigDecimal getBalance(Long walletId) {
        return walletRepo.getBalance(walletId);
    }
    public void debit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        wallet.debit(amount);
        walletRepo.updateBalance(walletId, wallet.balance());
    }
    public void credit(Long walletId, BigDecimal amount) {
        VirtualWalletEntity walletEntity = walletRepo.getWalletEntity(walletId);
        VirtualWallet wallet = convert(walletEntity);
        wallet.credit(amount);
        walletRepo.updateBalance(walletId, wallet.balance());
    }
    public void transfer(Long fromWalletId, Long toWalletId, BigDecimal amount) {
        VirtualWalletTransactionEntity transactionEntity = new VirtualWalletTransactionEntity();
        transactionEntity.setAmount(amount);
        transactionEntity.setCreateTime(System.currentTimeMillis());
        transactionEntity.setFromWalletId(fromWalletId);
        transactionEntity.setToWalletId(toWalletId);
        transactionEntity.setStatus(Status.TO_BE_EXECUTED);
        Long transactionId = transactionRepo.saveTransaction(transactionEntity);
        try {
            debit(fromWalletId, amount);
            credit(toWalletId, amount);
        } catch (InsufficientBalanceException e) {
            transactionRepo.updateStatus(transactionId, Status.CLOSED);
            ...
        } catch (Exception e) {
            transactionRepo.updateStatus(transactionId, Status.FAILED);
            ...
        }
        transactionRepo.updateStatus(transactionId, Status.EXECUTED);
    }
}
```

***辩证思考与灵活应用***

**在基于充血模型的 DDD 开发模式中，将业务逻辑移动到 Domain 中，Service 类变得很薄，但在我们的代码设计与实现中并没有完全将 Service 类去掉，这是为什么？或者说，Service 类在这种情况下担当的职责是什么？哪些功能逻辑会放到 Service 类中？**

Service 类负责与 Repository 交流：之所以让 VirtualWalletService 类与 Repository 打交道，而不是让领域模型 VirtualWallet 与 Repository 打交道，那是因为我们想保持领域模型的独立性，不与任何其他层的代码（Repository 层的代码）或开发框架（比如 Spring、MyBatis）耦合在一起，将流程性的代码逻辑（比如从 DB 中取数据、映射数据）与领域模型的业务逻辑解耦，让领域模型更加可复用。

Service 类负责跨领域模型的业务聚合功能：VirtualWalletService 类中的 transfer() 转账函数会涉及两个钱包的操作，因此这部分业务逻辑无法放到 VirtualWallet 类中，所以，我们暂且把转账业务放到 VirtualWalletService 类中了。

Service 类负责一些非功能性及与三方系统交互的工作：比如幂等、事务、发邮件、发消息、记录日志、调用其他系统的 RPC 接口等。

**在基于充血模型的 DDD 开发模式中，尽管 Service 层被改造成了充血模型，但是 Controller 层和 Repository 层还是贫血模型，是否有必要也进行充血领域建模呢？**

Controller 层主要负责接口的暴露，Repository 层主要负责与数据库打交道，这两层包含的业务逻辑并不多，前面我们也提到了，如果业务逻辑比较简单，就没必要做充血建模，即便设计成充血模型，类也非常单薄，看起来也很奇怪。

就拿 Repository 的 Entity 来说，即便它被设计成贫血模型，违反面向对象编程的封装特性，有被任意代码修改数据的风险，但 Entity 的生命周期是有限的。一般来讲，我们把它传递到 Service 层之后，就会转化成 BO 或者 Domain 来继续后面的业务逻辑，Entity 的生命周期到此就结束了，所以也并不会被到处任意修改。

我们再来说说 Controller 层的 VO，实际上 VO 是一种 DTO（Data Transfer Object，数据传输对象），它主要是作为接口的数据传输承载体将数据发送给其他系统，从功能上来讲，它理应不包含业务逻辑只包含数据。所以，我们将它设计成贫血模型也是比较合理的。

### 13 | 实战二（上）：如何对接口鉴权这样一个功能开发做面向对象分析？

***案例介绍和难点剖析***

**需求不明确**

面向对象分析主要的分析对象是“需求”，因此，面向对象分析可以粗略地看成“需求分析”。实际上，不管是需求分析还是面向对象分析，我们首先要做的都是将笼统的需求细化到足够清晰、可执行。我们需要通过沟通、挖掘、分析、假设、梳理来搞清楚具体的需求有哪些，哪些是现在要做的，哪些是未来可能要做的，哪些是不用考虑做的。

**缺少锻炼**

开发这样通用的框架，对工程师的需求分析能力、设计能力、编码能力甚至逻辑思维能力的要求都是比较高的。

***对案例进行需求分析***

提出问题，然后再解决问题，是一个非常好的迭代优化方法。

需求分析的过程实际上是一个不断迭代优化的过程，我们不要试图一下就能给出一个完美的解决方案，而是先给出一个粗糙的、基础的方案，有一个迭代的基础，然后再慢慢优化，这样一个思考过程能让我们摆脱无从下手的窘境。

### 14 | 实战二（下）：如何利用面向对象设计和编程开发接口鉴权功能？

***如何进行面向对象设计？***

面向对象分析的产出是详细的需求描述，那面向对象设计的产出就是类。

**划分职责进而识别出有哪些类**

在面向对象有关书籍中经常讲到，类是现实世界中事物的一个建模。但是，并不是每个需求都能映射到现实世界，也并不是每个类都与现实世界中的事物一一对应。对于一些抽象的概念，我们是无法通过映射现实世界中的事物的方式来定义类的。

把需求描述中的名词罗列出来，作为可能的候选类，然后再进行筛选。

根据需求描述，把其中涉及的功能点一个一个罗列出来，然后再去看哪些功能点职责相近，操作同样的属性，可否应该归为同一个类。

注意，拆解出来的每个功能点要尽可能的小，每个功能点只负责做一件很小的事情（专业叫法是“单一职责”）。

针对复杂的需求开发，我们首先要做的是进行模块划分，将需求先简单划分成几个小的、独立的功能模块，然后再在模块内部进行面向对象设计，而模块的划分和识别跟类的划分和识别是类似的套路。

**定义类及其属性和方法**

识别出需求描述中的动词作为候选的方法，再进一步过滤筛选。类比一下方法的识别，我们可以把功能点中涉及的名词作为候选属性，然后同样进行过滤筛选。

**定义类与类之间的交互关系**

UML 统一建模语言中定义了六种类之间的关系，它们分别是：泛化、实现、关联、聚合、组合、依赖。

泛化（Generalization）可以简单理解为继承关系。

```java
public class A { ... }
public class B extends A { ... }
```

实现（Realization）一般是指接口和实现类之间的关系。

```java
public interface A {...}
public class B implements A { ... }
```

聚合（Aggregation）是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期可以不依赖 A 类对象的生命周期，也就是说可以单独销毁 A 类对象而不影响 B 类对象。

```java
public class A {
    private B b;
    public A(B b) {
        this.b = b;
    }
}
```

组合（Composition）也是一种包含关系，A 类对象包含 B 类对象，B 类对象的生命周期依赖 A 类对象的生命周期，B 类对象不可单独存在。

```java
public class A {
    private B b;
    public A() {
        this.b = new B();
    }
}
```

关联（Association）是一种非常弱的关系，包含聚合、组合两种关系。具体到代码层面，如果 B 类对象是 A 类的成员变量，那 B 类和 A 类就是关联关系。

依赖（Dependency）是一种比关联关系更加弱的关系，包含关联关系。不管 B 类对象是 A 类对象的成员变量，还是 A 类的方法使用 B 类对象作为参数、返回值、局部变量，只要 B 类对象和 A 类对象有任何使用关系，我们都称它们有依赖关系。

泛化、实现、依赖的定义不变，组合关系替代 UML 中组合、聚合、关联三个概念，也就相当于重新命名关联关系为组合关系，并且不再区分 UML 中的组合和聚合两个概念。

**类组装起来并提供执行入口**

***辩证思考与灵活应用***

整个软件开发本来就是一个迭代、修修补补、遇到问题解决问题的过程，是一个不断重构的过程，我们没法严格地按照顺序执行各个步骤。

### 15 | 理论一：对于单一职责原则，如何判定某个类的职责是否够“单一”？

***如何理解单一职责原则（SRP）？***

A class or module should have a single responsibility.

一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。

***如何判断类的职责是否足够单一？***

不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。

评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类满足业务需求，随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类拆分成几个更细粒度的类，这就是所谓的持续重构。

**从侧面上判定一个类的职责是否够单一**

类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；

类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；

私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；

比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；

类中大量的方法都是集中操作类中的某几个属性，那就可以考虑将这几个属性和对应的方法拆分出来。

**那多少行代码才算是行数过多呢？多少个函数、属性才称得上过多呢？**

从另一个角度来看，当一个类的代码读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能却要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。

***类的职责是否设计得越单一越好？***

内聚性 / 可维护性

### 16 | 理论二：如何做到“对扩展开放、修改关闭”？扩展和修改各指什么？

***如何理解“对扩展开放、修改关闭”？***

software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.

添加一个新的功能应该是在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。

```java
public class Alert {
    private AlertRule rule;
    private Notification notification;

    public Alert(AlertRule rule, Notification notification) {
        this.rule = rule;
        this.notification = notification;
    }

    public void check(String api, long requestCount, long errorCount, long durationOfSeconds) {
        long tps = requestCount / durationOfSeconds;
        if (tps > rule.getMatchedRule(api).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
    }
}
```

```java
public class Alert {

    // ...

    // 改动一：添加参数 timeoutCount
    public void check(String api, long requestCount, long errorCount, long timeoutCount, long durationOfSeconds) {
        long tps = requestCount / durationOfSeconds;
        if (tps > rule.getMatchedRule(api).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
        if (errorCount > rule.getMatchedRule(api).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
        // 改动二：添加接口超时处理逻辑
        long timeoutTps = timeoutCount / durationOfSeconds;
        if (timeoutTps > rule.getMatchedRule(api).getMaxTimeoutTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
    }
}
```

一方面，我们对接口进行了修改，这就意味着调用这个接口的代码都要做相应的修改。另一方面，修改了 check() 函数，相应的单元测试都需要修改。

重构的内容主要包含两部分：

第一部分是将 check() 函数的多个入参封装成 ApiStatInfo 类；

第二部分是引入 handler 的概念，将 if 判断逻辑分散在各个 handler 中。

```java
public class Alert {
    private List<AlertHandler> alertHandlers = new ArrayList<>();

    public void addAlertHandler(AlertHandler alertHandler) {
        this.alertHandlers.add(alertHandler);
    }

    public void check(ApiStatInfo apiStatInfo) {
        for (AlertHandler handler : alertHandlers) {
            handler.check(apiStatInfo);
        }
    }
}

public class ApiStatInfo {
    private String api;
    private long requestCount;
    private long errorCount;
    private long durationOfSeconds;
}

public abstract class AlertHandler {
    protected AlertRule rule;
    protected Notification notification;
    public AlertHandler(AlertRule rule, Notification notification) {
        this.rule = rule;
        this.notification = notification;
    }
    public abstract void check(ApiStatInfo apiStatInfo);
}

public class TpsAlertHandler extends AlertHandler {
    public TpsAlertHandler(AlertRule rule, Notification notification) {
        super(rule, notification);
    }

    @Override
    public void check(ApiStatInfo apiStatInfo) {
        long tps = apiStatInfo.getRequestCount() / apiStatInfo.getDurationOfSeconds();
        if (tps > rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) {
            notification.notify(NotificationEmergencyLevel.URGENCY, "...");
        }
    }
}

public class ErrorAlertHandler extends AlertHandler {
    public ErrorAlertHandler(AlertRule rule, Notification notification){
        super(rule, notification);
    }

    @Override
    public void check(ApiStatInfo apiStatInfo) {
        if (apiStatInfo.getErrorCount() > rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) {
            notification.notify(NotificationEmergencyLevel.SEVERE, "...");
        }
    }
}
```

ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作。

```java
public class ApplicationContext {
    private AlertRule alertRule;
    private Notification notification;
    private Alert alert;

    public void initializeBeans() {
        alertRule = new AlertRule();
        notification = new Notification();
        alert = new Alert();
        alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
        alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
    }
    public Alert getAlert() { return alert; }

    private static final ApplicationContext instance = new ApplicationContext();
    private ApplicationContext() {
        instance.initializeBeans();
    }
    public static ApplicationContext getInstance() {
        return instance;
    }
}

public class Demo {
    public static void main(String[] args) {
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
    }
}
```

重构之后的代码添加新功能：

```java
public class Alert {
    // 代码未改动
}
public class ApiStatInfo {
    // ...
    // 改动一：添加新字段
    private long timeoutCount;
}
public abstract class AlertHandler {
    // 代码未改动
}
public class TpsAlertHandler extends AlertHandler {
    // 代码未改动
}
public class ErrorAlertHandler extends AlertHandler {
    // 代码未改动
}
// 改动二：添加新的 handler
public class TimeoutAlertHandler extends AlertHandler { ... }

public class ApplicationContext {
    // ...
  public void initializeBeans() {
      // ...
      alert.addAlertHandler(new TpsAlertHandler(alertRule, notification));
      alert.addAlertHandler(new ErrorAlertHandler(alertRule, notification));
      // 改动三：注册 handler
      alert.addAlertHandler(new TimeoutAlertHandler(alertRule, notification));
  }
  //...
}

public class Demo {
    public static void main(String[] args) {
        ApiStatInfo apiStatInfo = new ApiStatInfo();
        // ...
        // 改动四：设置 tiemoutCount
        apiStatInfo.setTimeoutCount(200);
        ApplicationContext.getInstance().getAlert().check(apiStatInfo);
}
```

***修改代码就意味着违背开闭原则吗？***

只要它没有破坏原有代码的正常运行，没有破坏原有的单元测试，我们就可以说这是一个合格的代码改动。

添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作才能构建成可运行的的程序，这部分代码的修改是在所难免的。

***如何做到“对扩展开放、修改关闭”？***

**为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。**

在写代码的时候，我们要多花点时间往前思考一下，这段代码未来可能有哪些需求变更？如何设计代码结构？事先留好扩展点以便在未来需求变更的时候不需要改动代码的整体结构，做到在最小代码改动的情况下将新的代码很灵活地插入到扩展点上，做到“对扩展开放、修改关闭”。

还有，在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口扩展一个新的实现来替换掉老的实现即可，上游系统的代码几乎不需要修改。

**在众多的设计原则、思想、模式中，最常用来提高代码扩展性的方法有：多态、依赖注入、基于接口而非实现编程，以及大部分的设计模式。**

```java
// 这一部分体现了抽象意识
public interface MessageQueue {...}
public class KafkaMessageQueue implements MessageQueue {...}
public class RocketMQMessageQueue implements MessageQueue {...}

public interface MessageFormatter {...}
public class JsonMessageFormatter implements MessageFormatter {...}
public class MessageFormatter implements MessageFormatter {...}

public class Demo {
    // 基于接口而非实现编程
    private MessageQueue msgQueue; 
    // 依赖注入
    public Demo(MessageQueue msgQueue) {
        this.msgQueue = msgQueue;
    }

    // msgFormatter：多态、依赖注入
    public void sendNotification(Notification notification, MessageFormatter msgFormatter) {...}
}
```

***如何在项目中灵活应用开闭原则？***

对于一些比较确定的、短期内可能就会扩展的需求，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以等到有需求驱动的时候再通过重构代码的方式来支持扩展的需求。

而且，开闭原则也并不是免费的，有些情况下代码的扩展性会跟可读性相冲突。

### 17 | 理论三：里氏替换（LSP）跟多态有何区别？哪些代码违背了LSP？

***如何理解“里氏替换原则”？***

If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.

Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.

子类对象（object of subtype / derived class）能够替换程序（program）中父类对象（object of base / parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变，即正确性不被破坏。

```java
// 里氏替换
public class SecurityTransporter extends Transporter {
    @Override
    public Response sendRequest(Request request) {
        if (StringUtils.isNotBlank(appId) && StringUtils.isNotBlank(appToken)) {
            request.addPayload("app-id", appId);
            request.addPayload("app-token", appToken);
        }
        return super.sendRequest(request);
    }
}

public class SecurityTransporter extends Transporter {
    @Override
    public Response sendRequest(Request request) {
        // 程序的逻辑行为有了改变
        if (StringUtils.isBlank(appId) || StringUtils.isBlank(appToken)) {
            throw new NoAuthorizationRuntimeException();
        }
        request.addPayload("app-id", appId);
        request.addPayload("app-token", appToken);
        return super.sendRequest(request);
    }
}
```

虽然从定义描述和代码实现上来看，多态和里氏替换有点类似，但它们关注的角度是不一样的。多态是面向对象编程的一大特性，也是面向对象编程语言的一种语法，它是一种代码实现的思路。而里氏替换是一种设计原则，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候不改变原有程序的逻辑，即不破坏原有程序的正确性。

***哪些代码明显违背了 LSP？***

Design By Contract，按照协议来设计。

父类定义了函数的行为约定，子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，定义中父类和子类之间的关系也可以替换成接口和实现类之间的关系。

判断子类的设计实现是否违背了里氏替换原则，还有一个小窍门，那就是拿父类的单元测试去验证子类的代码。如果某些单元测试运行失败，就有可能说明子类的设计实现没有完全遵守父类的约定，子类有可能违背了里氏替换原则。

### 18 | 理论四：接口隔离原则有哪三种应用？原则中的“接口”该如何理解？

***如何理解“接口隔离原则”？***

Clients should not be forced to depend upon interfaces that they do not use.

客户端不应该被强迫依赖它不需要的接口，其中的“客户端”可以理解为接口的调用者或者使用者。

***把“接口”理解为一组 API 接口集合***

```java
public interface UserService {
    boolean register(...);
    boolean login(...);
    UserInfo getUserInfoById(...);
    UserInfo getUserInfoByCellphone(...);
}

public class UserServiceImpl implements UserService {
    // ...
}
```

```java
public interface UserService {
    boolean register(...);
    boolean login(...);
    UserInfo getUserInfoById(...);
    UserInfo getUserInfoByCellphone(...);
}

public interface RestrictedUserService {
    boolean deleteUserByCellphone(...);
    boolean deleteUserById(...);
}

public class UserServiceImpl implements UserService, RestrictedUserService {
    // ...
}
```

在设计微服务或者类库接口的时候，如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用，而不是强迫其他调用者也依赖这部分不会被用到的接口。

***把“接口”理解为单个 API 接口或函数***

函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现。

```java
public class Statistics {
    private Long max;
    private Long min;
    private Long average;
    private Long sum;
    private Long percent99;
    private Long percent999;
    // ...
}

public Statistics count(Collection<Long> dataSet) {
    Statistics statistics = new Statistics();
    // ...
    return statistics;
}
```

```java
public Long max(Collection<Long> dataSet) {...}
public Long min(Collection<Long> dataSet) {...} 
public Long average(Colletion<Long> dataSet) {...}
```

单一职责原则针对的是模块、类、接口的设计，而接口隔离原则相对于单一职责原则，一方面它更侧重于接口的设计，另一方面它的思考角度不同，它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定，如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一。

***把“接口”理解为 OOP 中的接口概念***

```java
public class RedisConfig {
    private ConfigSource configSource;
    private String address;
    private int timeout;
    private int maxTotal;
    // ...
    public RedisConfig(ConfigSource configSource) {
        this.configSource = configSource;
    }
    public String getAddress() {
        return this.address;
    }
    // ...
}
public class KafkaConfig {...}
public class MysqlConfig {...}
```

```java
public interface Updater {
    void update();
}
public class RedisConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class KafkaConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class MysqlConfig {...}
public class ScheduledUpdater {
    private final ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();
    private long initialDelayInSeconds;
    private long periodInSeconds;
    private Updater updater;
    public ScheduleUpdater(Updater updater, long initialDelayInSeconds, long periodInSeconds) {
        this.updater = updater;
        this.initialDelayInSeconds = initialDelayInSeconds;
        this.periodInSeconds = periodInSeconds;
    }

    public void run() {
        executor.scheduleAtFixedRate(new Runnable() {
            @Override
            public void run() {
                updater.update();
            }
        }, this.initialDelayInSeconds, this.periodInSeconds, TimeUnit.SECONDS);
    }
}
public class Application {
    ConfigSource configSource = new ZookeeperConfigSource(/*省略参数*/);
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MysqlConfig(configSource);
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
    }
}
```

```java
public interface Updater {
    void update();
}
public interface Viewer {
    String outputInPlainText();
    Map<String, String> output();
}
public class RedisConfig implements Updater, Viewer {
    // ...
    @Override
    public void update() {...}
    @Override
    public String outputInPlainText() {...}
    @Override
    public Map<String, String> output() {...}
}
public class KafkaConfig implements Updater {
    // ...
    @Override
    public void update() {...}
}
public class MysqlConfig implements Viewer {
    // ...
    @Override
    public String outputInPlainText() {...}
    @Override
    public Map<String, String> output() {...}
}
public class SimpleHttpServer {
    private String host;
    private int port;
    private Map<String, List<Viewer>> viewers = new HashMap<>();
    public SimpleHttpServer(String host, int port) {...}
    public void addViewers(String urlDirectory, Viewer viewer) {
        if (!viewers.containsKey(urlDirectory)) {
            viewers.put(urlDirectory, new ArrayList<Viewer>());
        }
        this.viewers.get(urlDirectory).add(viewer);
    }
    public void run() {...}
}
public class Application {
    ConfigSource configSource = new ZookeeperConfigSource();
    public static final RedisConfig redisConfig = new RedisConfig(configSource);
    public static final KafkaConfig kafkaConfig = new KakfaConfig(configSource);
    public static final MySqlConfig mysqlConfig = new MySqlConfig(configSource);
    public static void main(String[] args) {
        ScheduledUpdater redisConfigUpdater = new ScheduledUpdater(redisConfig, 300, 300);
        redisConfigUpdater.run();
        ScheduledUpdater kafkaConfigUpdater = new ScheduledUpdater(kafkaConfig, 60, 60);
        redisConfigUpdater.run();
        SimpleHttpServer simpleHttpServer = new SimpleHttpServer(“127.0.0.1”, 2389);
        simpleHttpServer.addViewer("/config", redisConfig);
        simpleHttpServer.addViewer("/config", mysqlConfig);
        simpleHttpServer.run();
    }
}
```

我们设计了两个功能非常单一的接口：Updater 和 Viewer。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则。

### 19 | 理论五：控制反转、依赖反转、依赖注入，这三者有何区别和联系？

***控制反转（IOC）***

框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程。程序员利用框架进行开发的时候，只需要往预留的扩展点上添加跟自己业务相关的代码，就可以利用框架来驱动整个程序流程的执行。

这里的“控制”指的是对程序执行流程的控制，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行，在使用框架之后，整个程序的执行流程可以通过框架来控制，流程的控制权从程序员“反转”到了框架。

控制反转并不是一种具体的实现技巧，而是一个比较笼统的设计思想，一般用来指导框架层面的设计。

***依赖注入（DI）***

不通过 new() 的方式在类内部创建依赖类对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用。

通过依赖注入的方式将依赖的类对象传递进来，这样就提高了代码的扩展性，我们可以灵活地替换依赖的类。

***依赖注入框架（DI Framework）***

我们只需要通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。

***依赖反转原则（DIP）***

依赖反转原则也叫作依赖倒置原则，这条原则跟控制反转有点类似，主要用来指导框架层面的设计。

High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.

高层模块不要依赖低层模块。高层模块和低层模块应该通过抽象来互相依赖。除此之外，抽象不要依赖具体实现细节，具体实现细节依赖抽象。

Tomcat 是运行 Java Web 应用程序的容器，我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块，Tomcat 和应用程序代码之间并没有直接的依赖关系，两者都依赖同一个“抽象”，也就是 Servlet 规范。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。

### 20 | 理论六：我为何说 KISS、YAGNI 原则看似简单，却经常被用错？

***如何理解“KISS 原则”？***

Keep It Simple and Stupid.

Keep It Short and Simple.

Keep It Simple and Straightforward.

KISS 原则是保持代码可读和可维护的重要手段，代码足够简单，也就意味着很容易读懂，bug 比较难隐藏，即便出现 bug，修复起来也比较简单。

***代码行数越少就越“简单”吗？***

并不是代码行数越少就越“简单”，还要考虑逻辑复杂度、实现难度、代码的可读性等。

***代码逻辑复杂就违背 KISS 原则吗？***

本身就复杂的问题用复杂的方法解决并不违背 KISS 原则。

平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本，在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。

同样的代码在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了。

***如何写出满足 KISS 原则的代码？***

不要使用同事可能不懂的技术来实现代码；不要重复造轮子，要善于使用已经有的工具类库；不要过度优化，不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。

评判代码是否简单，还有一个很有效的间接方法，那就是 code review。

越是能用简单的方法解决复杂的问题，越能体现一个人的能力。

***YAGNI 跟 KISS 说的是一回事吗？***

You Ain’t Gonna Need It.

不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：不要做过度设计。

KISS 原则讲的是“如何做”的问题（尽量保持简单），而 YAGNI 原则说的是“要不要做”的问题（当前不需要的就不要做）。

### 21 | 理论七：重复的代码就一定违背 DRY 吗？如何提高代码的复用性？

***DRY 原则（Don’t Repeat Yourself）***

**实现逻辑重复**

尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则。

**功能语义重复**

尽管两段代码的实现逻辑不重复，但语义重复，也就是功能重复，我们认为它违反了 DRY 原则。

**代码执行重复**

```java
public class UserService {
    private UserRepo userRepo;
    public User login(String email, String password) {
        // 代码执行重复
        boolean existed = userRepo.checkIfUserExisted(email, password);
        if (!existed) {
            // ...
        }
        User user = userRepo.getUserByEmail(email);
        return user;
    }
}

public class UserRepo {
    public boolean checkIfUserExisted(String email, String password) {
        // 代码执行重复
        if (!EmailValidation.validate(email)) {
            // ...
        }
        if (!PasswordValidation.validate(password)) {
            // ...
        }
        // ...
    }
    public User getUserByEmail(String email) {
        // 代码执行重复
        if (!EmailValidation.validate(email)) {
            // ...
        }
        // ...
    }
}
```

```java
public class UserService {
    private UserRepo userRepo;
    public User login(String email, String password) {
        if (!EmailValidation.validate(email)) {
            // ...
        }
        if (!PasswordValidation.validate(password)) {
            // ...
        }
        User user = userRepo.getUserByEmail(email);
        if (user == null || !password.equals(user.getPassword()) {
            // ...
        }
    }
}

public class UserRepo {
    public boolean checkIfUserExisted(String email, String password) {
        // ...
    }
    public User getUserByEmail(String email) {
        // ...
    }
}
```

***代码复用性（Code Reusability）***

**什么是代码的复用性？**

代码复用表示一种行为，我们在开发新功能的时候，尽量复用已经存在的代码。代码的可复用性表示一段代码可被复用的特性或能力，我们在编写代码的时候，让代码尽量可复用。DRY 原则是一条原则，不要写重复的代码。

**怎么提高代码复用性？**

*减少代码耦合*

*满足单一职责原则*

*模块化*

*业务与非业务逻辑分离*

*通用代码下沉*

*继承、多态、抽象、封装*

*应用模板等设计模式*

除了上面讲到的这些方法之外，复用意识也非常重要。我们在写代码的时候，要多去思考一下这部分代码是否可以抽取出来作为一个独立的模块、类或者函数供多处使用。在设计每个模块、类、函数的时候要像设计一个外部 API 那样去思考它的复用性。

***辩证思考和灵活应用***

我们在第一次写代码的时候，如果当下没有复用的需求，而未来的复用需求也不是特别明确，并且开发可复用代码的成本比较高，那我们就不需要考虑代码的复用性。在之后我们开发新的功能的时候，发现可以复用之前写的这段代码，那我们就重构这段代码，让其变得更加可复用。

### 22 | 理论八：如何用迪米特法则（LOD）实现“高内聚、松耦合”？

***何为“高内聚、松耦合”？***

“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。

在这个设计思想中，“高内聚”用来指导类本身的设计，“松耦合”用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干，高内聚有助于松耦合，松耦合又需要高内聚的支持。

**什么是“高内聚”？**

所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，修改会比较集中，代码容易维护。

**什么是“松耦合”**

所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，一个类的代码改动不会或者很少导致依赖类的代码改动。

***“迪米特法则”理论描述***

它还有另外一个更加达意的名字，叫作最小知识原则。

Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.

Each unit should only talk to its friends; don't talk to strangers.

Only talk to your immediate friends.

**不该有直接依赖关系的类之间，不要有依赖**

```java
public class NetworkTransporter {
    public Byte[] send(HtmlRequest htmlRequest) {
        // ...
    }
}
public class HtmlDownloader {
    private NetworkTransporter transporter;
    public Html downloadHtml(String url) {
        Byte[] rawHtml = transporter.send(new HtmlRequest(url));
        return new Html(rawHtml);
    }
}
public class Document {
    private Html html;
    private String url;
    public Document(String url) {
        this.url = url;
        HtmlDownloader downloader = new HtmlDownloader();
        this.html = downloader.downloadHtml(url);
    }
    // ...
}
```

*NetworkTransporter*

作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，依赖了不该有直接依赖关系的 HtmlRequest 类。

```java
public class NetworkTransporter {
    public Byte[] send(String address, Byte[] data) {
        // ...
    }
}
```

*HtmlDownloader*

```java
public class HtmlDownloader {
    private NetworkTransporter transporter;
    public Html downloadHtml(String url) {
        HtmlRequest htmlRequest = new HtmlRequest(url);
        Byte[] rawHtml = transporter.send(htmlRequest.getAddress(), htmlRequest.getContent().getBytes());
        return new Html(rawHtml);
    }
}
```

*Document*

构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性。

HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想，也会影响到代码的可测试性。

从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则。

```java
public class Document {
    private Html html;
    private String url;
    public Document(String url, Html html) {
        this.html = html;
        this.url = url;
    }
    //...
}
// 通过工厂方法创建 Document
public class DocumentFactory {
    private HtmlDownloader downloader;
    public DocumentFactory(HtmlDownloader downloader) {
        this.downloader = downloader;
    }
    public Document createDocument(String url) {
        Html html = downloader.downloadHtml(url);
        return new Document(url, html);
    }
}
```

**有依赖关系的类之间，尽量只依赖必要的接口**

```java
public class Serialization {
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
```

只用到序列化操作的类不应该依赖反序列化接口，同理，只用到反序列化操作的类不应该依赖序列化接口。

```java
public class Serializer {
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
}
public class Deserializer {
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
```

尽管拆分之后的代码更能满足迪米特法则，但却违背了高内聚的设计思想。

```java
public interface Serializable {
    String serialize(Object object);
}
public interface Deserializable {
    Object deserialize(String text);
}
public class Serialization implements Serializable, Deserializable {
    @Override
    public String serialize(Object object) {
        String serializedResult = ...;
        // ...
        return serializedResult;
    }
    @Override
    public Object deserialize(String str) {
        Object deserializedResult = ...;
        // ...
        return deserializedResult;
    }
}
public class DemoClass_1 {
    private Serializable serializer;
    public Demo(Serializable serializer) {
        this.serializer = serializer;
    }
    //...
}
public class DemoClass_2 {
    private Deserializable deserializer;
    public Demo(Deserializable deserializer) {
        this.deserializer = deserializer;
    }
    //...
}
```

“基于接口而非实现编程”的设计原则结合迪米特法则，我们可以总结出一条新的设计原则，那就是“基于最小接口而非最大实现编程”。

### 23 | 实战一（上）：针对业务系统的开发，如何做需求分析和设计？

***需求分析***

除了刚刚讲的“借鉴”的思路之外，我还喜欢通过产品的线框图、用户用例（user case）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。

用户用例侧重情景化，其实就是模拟用户如何使用我们的产品，描述用户在一个特定的应用场景里的一个完整的业务操作流程。

***系统设计***

面向对象设计聚焦在代码层面（主要是针对类），系统设计聚焦在架构层面（主要是针对模块），两者有很多相似之处。很多设计原则和思想不仅仅可以应用到代码设计中，还能用到架构设计中。

**合理地将功能划分到不同模块**

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然，那代码的质量就不会差到哪里去。类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

怎么判断模块划分是否合理呢？实际上，我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。如果一个功能的修改或添加经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。

除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般来讲，我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息，但是，可以接受上层系统包含下层系统的业务信息。比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。

**设计模块与模块之间的交互关系**

在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。

比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。

除此之外，上下层系统之间的调用倾向于通过同步接口，同层系统之间的调用倾向于异步消息。

### 24 | 实战一（下）：如何实现一个遵从设计原则的积分兑换系统？

**设计模块的接口、数据库、业务模型**

数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。改动数据库表结构，需要涉及数据的迁移和适配；改动接口，需要推动接口的使用者作相应的代码修改。这两种情况，即便是微小的改动，执行起来都会非常麻烦。

***为什么要分 MVC 三层开发？***

**分层能起到代码复用的作用**

同一个 Repository 可能会被多个 Service 调用，同一个 Service 可能会被多个 Controller 调用。

如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。

**分层能起到隔离变化的作用**

分层体现了一种抽象和封装的设计思想。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。

除此之外，Controller、Service、Repository 三层代码的稳定程度不同，引起变化的原因也不同，所以分成三层来组织代码能有效地隔离变化。

**分层能起到隔离关注点的作用**

三层之间的关注点不同，分层之后职责更加分明，更加符合单一职责原则，代码的内聚性更好。

**分层能提高代码的可测试性**

单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repository 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库注入到 Service 层代码中。

**分层能应对系统的复杂性**

拆分有垂直和水平两个方向，水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。

***BO、VO、Entity 存在的意义是什么？***

VO、BO、Entity 并非完全一样；VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的；为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象再继续处理。

### 25 | 实战二（上）：针对非业务的通用框架开发，如何做需求分析和设计？

***需求分析***

**功能性需求分析**

相对于一大长串的文字描述，人脑更容易理解短的、罗列比较规整的、分门别类的列表信息。

**非功能性需求分析**

易用性；性能；扩展性；容错性；通用性。

***框架设计***

借鉴 TDD（测试驱动开发）和 Prototype（最小原型）的思想，先聚焦于一个简单的应用场景，基于此设计实现一个简单的原型。尽管这个最小原型系统在功能和非功能特性上都不完善，但它能够看得见摸得着，比较具体不抽象，能够很有效地帮助我捋清更复杂的设计思路，是迭代设计的基础。

### 26 | 实战二（下）：如何实现一个支持各种统计规则的性能计数器？

***小步快跑、逐步迭代***

我们应该分多个版本逐步完善这个框架，第一个版本可以先实现一些基本功能，对于更高级、更复杂的功能，以及非功能性需求不做过高的要求，在后续的 v2.0、v3.0 ... 版本中继续迭代优化。