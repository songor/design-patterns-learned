# 设计模式之美

### 开篇词 | 一对一的设计与编码集训，让你告别没有成长的烂代码！

### 01 | 为什么说每个程序员都要尽早地学习并掌握设计模式相关知识？

### 02 | 从哪些维度评判代码质量的好坏？如何具备写出高质量代码的能力？

***如何评价代码质量的高低？***

代码质量高低是一个综合各种因素得到的结论，我们并不能通过单一的维度去评价一段代码的好坏。

不同的评价维度也并不是完全独立的，有些是具有包含关系、重叠关系或者可以互相影响的。而且，各种评价维度也不是非黑即白的。

对一段代码的质量评价，常常有很强的主观性。

***最常用的评价标准有哪几个？***

**可维护性（maintainability）**

我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。

***可读性（readability）***

实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时有很多疑问，那就说明你的代码可读性有待提高了。

**可扩展性（extensibility）**

说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。

**灵活性（flexibility）**

**简洁性（simplicity）**

实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。

**可复用性（reusability）**

**可测试性（testability）**

代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。

***如何才能写出高质量的代码？***

问如何写出高质量的代码，也就等同于在问如何写出易维护、易读、易扩展、灵活、简洁、可复用、可测试的代码。

要写出满足这些评价标准的高质量代码，我们需要掌握一些更加细化、更加能落地的编程方法论，包括面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

### 03 | 面向对象、设计原则、设计模式、编程规范、重构，这五者有何关系？

***面向对象***

面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。

***设计原则***

对于每一种设计原则，我们需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景。

***设计模式***

设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。

这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。

***编程规范***

***代码重构***

不仅仅是掌握一些重构技巧、套路，更重要的是建立持续重构意识，把重构当作开发的一部分，融入到日常的开发中。

***五者之间的联系***

实际上，面向对象、设计原则、设计模式、编程规范、代码重构，这五者都是保持或者提高代码质量的方法论，本质上都是服务于编写高质量代码这一件事的。

### 04 | 理论一：当谈论面向对象的时候，我们到底在谈论什么？

***什么是面向对象编程和面向对象编程语言？***

面向对象编程是一种编程范式或编程风格，它以类或对象作为组织代码的基本单元，并将封装、抽象、继承、多态四个特性作为代码设计和实现的基石 。

面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言。

一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的。

***如何判定某编程语言是否是面向对象编程语言？***

我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制、是否完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。

***什么是面向对象分析和面向对象设计？***

分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。

简单点讲，面向对象分析就是要搞清楚做什么，面向对象设计就是要搞清楚怎么做，面向对象编程就是将分析和设计的的结果翻译成代码的过程。

### 05 | 理论二：封装、抽象、继承、多态分别可以解决哪些编程问题？

***封装（Encapsulation）***

封装也叫作信息隐藏或者数据访问保护。类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。

对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持，这个语法机制就是访问权限控制。

**封装的意义是什么？它能解决什么编程问题？**

如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，势必影响代码的可读性、可维护性。

除此之外，类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解，而这对于调用者来说也是一种负担。

***抽象（Abstraction）***

抽象讲的是如何隐藏方法的具体实现，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。

在面向对象编程中，我们常借助编程语言提供的接口类（比如 Java 中的 interface 关键字语法）或者抽象类（比如 Java 中的 abstract 关键字语法）这两种语法机制来实现抽象这一特性。

类的方法是通过编程语言中的“函数”这一语法机制来实现的，通过函数包裹具体的实现逻辑，这本身就是一种抽象。调用者在使用函数的时候，并不需要去研究函数内部的实现逻辑，只需要通过函数的命名、注释或者文档了解其提供了什么功能，就可以直接使用了。

抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，只需要提供“函数”这一非常基础的语法机制就可以实现抽象特性，所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。

**抽象的意义是什么？它能解决什么编程问题？**

在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。

除此之外，抽象作为一个非常宽泛的设计思想，在代码设计中起到非常重要的指导作用。很多设计原则都体现了抽象这种设计思想，比如基于接口而非实现编程、开闭原则（对扩展开放，对修改关闭）、代码解耦（降低代码的耦合性）等。

换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，不要在方法定义中暴露太多的实现细节，以保证在某个时间点需要改变方法的实现逻辑的时候不用去修改其定义。

***继承（Inheritance）***

继承是用来表示类之间的 is-a 关系，比如猫是一种哺乳动物。

为了实现继承这个特性，编程语言需要提供特殊的语法机制来支持，比如 Java 使用 extends 关键字来实现继承。

**继承存在的意义是什么？它能解决什么编程问题？**

继承最大的一个好处就是代码复用。不过，这并不是继承所独有的，我们可以通过其他方式来解决代码复用的问题，比如利用组合关系而不是继承关系。

猫属于哺乳动物，从人类认知的角度上来说是一种 is-a 关系。我们通过继承来关联两个类，反应真实世界中的这种关系，非常符合人类的认知，而且，从设计的角度来说，也有一种结构美感。

***多态（Polymorphism）***

多态是指子类可以替换父类，在实际的代码运行过程中调用子类的方法实现。

**多态特性的实现方式**

利用继承加方法重写

利用接口类语法

利用 duck-typing 语法

**多态特性存在的意义是什么？它能解决什么编程问题？**

多态特性能提高代码的可扩展性和复用性。

除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里氏替换原则、利用多态去掉冗长的 if-else 语句等等。

### 06 | 理论三：面向对象相比面向过程有哪些优势？面向过程真的过时了吗？

***什么是面向过程编程与面向过程编程语言？***

面向过程编程是一种编程范式或编程风格，它以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能。

面向过程编程语言最大的特点是不支持类和对象两个语法概念，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程。

面向过程风格的代码被组织成了一组方法集合及其数据结构，方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。

***面向对象编程相比面向过程编程有哪些优势？***

**OOP 更加能够应对大规模复杂程序的开发**

因为需求足够简单，整个程序的处理流程只有一条主线，很容易被划分成顺序执行的几个步骤，然后逐句翻译成代码，这就非常适合采用面向过程这种面条式的编程风格来实现。

对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线，如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法就会比较吃力。

面向对象编程以类为思考对象，在进行面向对象编程的时候，我们并不是一上来就去思考如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候思路更加清晰。

类就是一种非常好的组织这些函数和数据结构的方式，是一种将代码模块化的有效手段。

**OOP 风格的代码更易复用、易扩展、易维护**

面向对象编程提供的封装、抽象、继承、多态这些特性，能极大地满足复杂的编程需求，能方便我们写出更易复用、易扩展、易维护的代码。

**OOP 语言更加人性化、更加高级、更加智能**

在进行面向对象编程时候，我们是在思考如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。

### 07 | 理论四：哪些代码设计看似是面向对象，实际是面向过程的？

***哪些代码设计看似是面向对象，实际是面向过程的？***

**滥用 getter、setter 方法**

它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。

在设计实现类的时候，除非真的需要，否则，尽量不要给属性定义 setter 方法。除此之外，尽管 getter 方法相对 setter 方法要安全些，但是如果返回的是集合容器，也要防范集合内部数据被修改的危险。

**滥用全局变量和全局方法**

在面向对象编程中，常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法。

大而全的 Constants 类

影响代码的可维护性；增加代码的编译时间，每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间；影响代码的复用性。

将 Constants 类拆解为功能更加单一的多个类；不单独地设计 Constants 常量类，而是哪个类用到了某个常量，我们就把这个常量定义到这个类中，这样也提高了类设计的内聚性和代码的复用性。

Utils 类

仅仅为了代码复用，生硬地抽象出一个父类出来，会影响到代码的可读性。

实际上，只包含静态方法不包含任何属性的 Utils 类，是彻彻底底的面向过程的编程风格。但这并不是说，我们就要杜绝使用 Utils 类了。

**定义数据和方法分离的类**

一般情况下，VO、BO、Entity 中只会定义数据，不会定义方法，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中，这就是典型的面向过程的编程风格。

***在面向对象编程中，为什么容易写出面向过程风格的代码？***

你在生活中去完成一个任务，一般都会思考应该先做什么后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。面向过程编程风格恰恰符合人的这种流程化思维方式。而面向对象编程风格正好相反，它是一种自底向上的思考方式。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来完成整个任务。

在面向对象编程中，类的设计还是挺需要技巧的，挺需要一定设计经验的。你要去思考如何封装合适的数据和方法到一个类里，如何设计类之间的关系，如何设计类之间的交互等等诸多设计问题。

***面向过程编程及面向过程编程语言就真的无用武之地了吗？***

如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主数据为辅，那脚本式的面向过程的编程风格就更适合一些。

面向对象和面向过程两种编程风格也并不是非黑即白、完全对立的。不管使用面向过程还是面向对象哪种风格来写代码，我们最终的目的还是写出易维护、易读、易复用、易扩展的高质量代码。

### 08 | 理论五：接口 vs 抽象类的区别？如何用普通的类模拟抽象类和接口？

***什么是抽象类和接口？区别在哪里？***

**抽象类**

抽象类不允许被实例化，只能被继承。

抽象类可以包含属性和方法。方法既可以包含代码实现，也可以不包含代码实现，不包含代码实现的方法叫作抽象方法。

子类继承抽象类，必须实现抽象类中的所有抽象方法。

**接口**

接口不能包含属性（也就是成员变量）。

接口只能声明方法，方法不能包含代码实现。

类实现接口的时候，必须实现接口中声明的所有方法。

**区别**

继承关系是一种 is-a 的关系，抽象类既然属于类，也表示一种 is-a 的关系。相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是协议（contract）。

***抽象类和接口能解决什么编程问题？***

**我们为什么需要抽象类？它能够解决什么编程问题？**

```java
public class Logger {
    protected boolean isLoggable() {...}
}
public class FileLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路虽然达到了代码复用的目的，但是无法使用多态特性了。

```java
Logger logger = new FileLogger();
// 编译错误
logger.log(Level.ERROR, "");
```

```java
public class Logger {
    protected boolean isLoggable() {...}
    public void log(Level level, String mesage) {}
}
public class FileLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
public class MessageQueueLogger extends Logger {
    @Override
    public void log(Level level, String mesage) {
        if (!isLoggable()) return;
        ...
    }
}
```

这个设计思路能用，但是，它显然没有通过抽象类的实现思路优雅：

在 Logger 中定义一个空的方法，会影响代码的可读性。

当创建一个新的子类继承 Logger 父类的时候，我们有可能会忘记重新实现 log() 方法。

Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法，这也增加了类被误用的风险。

**我们为什么需要接口？它能够解决什么编程问题？**

抽象类更多的是为了代码复用，而接口就更侧重于解耦。接口是对行为的一种抽象，相当于一组协议或者契约。

接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。

***如何决定该用抽象类还是接口？***

如果我们要表示一种 is-a 的关系，并且是为了解决代码复用的问题，我们就使用抽象类；如果我们要表示一种 has-a 的关系，并且为了解决抽象而非代码复用的问题，我们就使用接口。

从类的继承层次上来看，抽象类是一种自下而上的设计思路，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而接口正好相反，它是一种自上而下的设计思路，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。

### 09 | 理论六：为什么基于接口而非实现编程？有必要为每个类都定义接口吗？

***如何解读“基于接口而非实现编程”中的“接口”二字？***

从本质上来看，“接口”就是一组“协议”或者“约定”，是功能提供者提供给使用者的一个“功能列表”。

如果落实到具体的编码，“基于接口而非实现编程”这条原则中的“接口”，可以理解为编程语言中的接口或者抽象类。

应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。

在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。越抽象、越顶层、越脱离具体某一实现的设计越能提高代码的灵活性，越能应对未来的需求变化。好的代码设计不仅能应对当下的需求，而且在将来需求发生变化的时候仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。

***如何将这条原则应用到实战中？***

```java
public class AliyunImageStore {
    public void createBucketIfNotExisting(String bucketName) {...}
    public String generateAccessToken() {...}
    public String uploadToAliyun(Image image, String bucketName, String accessToken) {...}
    public Image downloadFromAliyun(String url, String accessToken) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        AliyunImageStore imageStore = new AliyunImageStore();
        imageStore.createBucketIfNotExisting(BUCKET_NAME);
        String accessToken = imageStore.generateAccessToken();
        imagestore.uploadToAliyun(image, BUCKET_NAME, accessToken);
    }
}
```

新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法在 PrivateImageStore 类中都逐一定义并重新实现一遍。

**“魔鬼细节”**

AliyunImageStore 类中有些函数命名暴露了实现细节，比如，uploadToAliyun() 和 downloadFromAliyun()。而我们把这种包含“aliyun”字眼的方法照抄到 PrivateImageStore 类中显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大。

将图片存储到阿里云的流程跟存储到私有云的流程可能并不是完全一致的。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整。

**“基于接口而非实现编程”**

函数的命名不能暴露任何实现细节。

封装具体的实现细节。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法给调用者使用。

为实现类定义抽象的接口。具体的实现类都依赖统一的接口定义，遵从一致的上传（或下载）功能协议。使用者依赖接口，而不是具体的实现类来编程。

```java
public interface ImageStore {
    String upload(Image image, String bucketName);
    Image download(String url);
}

public class AliyunImageStore implements ImageStore {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        String accessToken = generateAccessToken();
        ...
    }
    public Image download(String url) {
        String accessToken = generateAccessToken();
        ...
    }
    private void createBucketIfNotExisting(String bucketName) {...}
    private String generateAccessToken() {...}
}

public class PrivateImageStore implements ImageStore  {
    public String upload(Image image, String bucketName) {
        createBucketIfNotExisting(bucketName);
        ...
    }
    public Image download(String url) {...}
    private void createBucketIfNotExisting(String bucketName) {...}
}

public class ImageProcessingJob {
    private static final String BUCKET_NAME = "ai_images_bucket";
    public void process() {
        Image image = ...;
        ImageStore imageStore = new PrivateImageStore();
        imagestore.upload(image, BUCKET_NAME);
    }
}
```

我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节，接口的定义只表明做什么而不是怎么做。而且，在设计接口的时候，我们要多思考一下这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候不需要任何接口定义的改动。

***是否需要为每个类定义接口？***

如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，直接使用实现类就可以了。